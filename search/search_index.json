{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started \u00b6 JDA is distributed through MavenCentral, allowing you an easy inclusion into your Java project by the dependency manager of your choice. Configuration \u00b6 Maven Maven (No Audio) Gradle Gradle (No Audio) <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> VERSION </version> </dependency> <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> VERSION </version> <exclusions> <exclusion> <groupId> club.minnced </groupId> <artifactId> opus-java </artifactId> </exclusion> </exclusions> </dependency> repositories { mavenCentral () } dependencies { implementation ( \"net.dv8tion:JDA:VERSION\" ) } repositories { mavenCentral () } dependencies { implementation ( \"net.dv8tion:JDA:VERSION\" ) { exclude module: 'opus-java' } }","title":"Home"},{"location":"#getting-started","text":"JDA is distributed through MavenCentral, allowing you an easy inclusion into your Java project by the dependency manager of your choice.","title":"Getting Started"},{"location":"#configuration","text":"Maven Maven (No Audio) Gradle Gradle (No Audio) <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> VERSION </version> </dependency> <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> VERSION </version> <exclusions> <exclusion> <groupId> club.minnced </groupId> <artifactId> opus-java </artifactId> </exclusion> </exclusions> </dependency> repositories { mavenCentral () } dependencies { implementation ( \"net.dv8tion:JDA:VERSION\" ) } repositories { mavenCentral () } dependencies { implementation ( \"net.dv8tion:JDA:VERSION\" ) { exclude module: 'opus-java' } }","title":"Configuration"},{"location":"contributing/contributing/","text":"Setting up your Environment \u00b6 Create a Fork (If you already have a local repository skip to step 3) Clone Repository $ git clone https://github.com/ExampleName/JDA.git # (1) Cloning into 'JDA' ... remote: Counting objects: 15377 , done . remote: Total 15377 ( delta 0 ) , reused 0 ( delta 0 ) , pack-reused 15377 Receiving objects: 100 % ( 15377 /15377 ) , 21 .64 MiB | 2 .36 MiB/s, done . Resolving deltas: 100 % ( 8584 /8584 ) , done . Checking connectivity... done . Make sure to replace ExampleName with your GitHub Username. Move to your local repository (here JDA ) cd JDA Configure upstream remote to keep your fork updated $ git remote add upstream https://github.com/DV8FromTheWorld/JDA.git Create branch based on upstream/master $ git fetch upstream master From https://github.com/DV8FromTheWorld/JDA * branch master -> FETCH_HEAD * [ new branch ] master -> upstream/master $ git checkout -b patch-1 upstream/master Switched to a new branch 'patch-1' Making Changes \u00b6 Depending on your changes there are certain rules you have to follow if you expect your Pull Request to be merged. Note : It is recommended to create a new remote branch for each Pull Request based on the current upstream/master changes! Adding a new Method or Class If your addition is not internal (e.g. an impl class or private method) you have to write documentation. For that please follow the JavaDoc template Keep your code consistent! Follow the Structure Guide Compare your code style to the one used all over JDA and ensure you do not break the consistency (if you find issues in the JDA style you can include and update it) Example Bad Addition Good Addition + public void reset() { + name.reset(); + avatar.reset(); + + if (isType(AccountType.CLIENT)) { + email.reset(); + password.reset(); + } + } + /* + * Resets all {@link net.dv8tion.jda.core.managers.fields.AccountField Fields} + * for this manager instance by calling + * {@link net.dv8tion.jda.core.managers.fields.Field#reset() Field.reset()} sequentially + */ + public void reset() + { + name.reset(); + avatar.reset(); + + if (isType(AccountType.CLIENT)) + { + email.reset(); + password.reset(); + } + } Making a Commit While having multiple commits can help the reader understand your changes, it might sometimes be better to include more changes in a single commit. When you commit your changes write a proper commit caption which explains what you have done Updating your Fork Before you start committing make sure your fork is updated. (See Syncing a Fork or Keeping a Fork Updated ) Creating a Pull Request \u00b6 Commit your changes $ git commit -am \"Updated Copyright in build.gradle\" [ patch-1 340383d ] Updated Copyright in build.gradle 1 file changed, 1 insertion ( + ) , 1 deletion ( - ) Push your commits $ git push origin patch-1 Counting objects: 3 , done . Delta compression using up to 8 threads. Compressing objects: 100 % ( 3 /3 ) , done . Writing objects: 100 % ( 3 /3 ) , 313 bytes | 0 bytes/s, done . Total 3 ( delta 2 ) , reused 0 ( delta 0 ) remote: Resolving deltas: 100 % ( 2 /2 ) , completed with 2 local objects. To https://github.com/ExampleName/JDA.git * [ new branch ] patch-1 -> patch-1 Open Pull-Request Set base branch to base fork: DV8FromTheWorld/JDA base: development (OR base: docs/development ) Allow edits from Maintainers Done! Just click Create pull request and await a review by one of the maintainers!","title":"Contributing"},{"location":"contributing/contributing/#setting-up-your-environment","text":"Create a Fork (If you already have a local repository skip to step 3) Clone Repository $ git clone https://github.com/ExampleName/JDA.git # (1) Cloning into 'JDA' ... remote: Counting objects: 15377 , done . remote: Total 15377 ( delta 0 ) , reused 0 ( delta 0 ) , pack-reused 15377 Receiving objects: 100 % ( 15377 /15377 ) , 21 .64 MiB | 2 .36 MiB/s, done . Resolving deltas: 100 % ( 8584 /8584 ) , done . Checking connectivity... done . Make sure to replace ExampleName with your GitHub Username. Move to your local repository (here JDA ) cd JDA Configure upstream remote to keep your fork updated $ git remote add upstream https://github.com/DV8FromTheWorld/JDA.git Create branch based on upstream/master $ git fetch upstream master From https://github.com/DV8FromTheWorld/JDA * branch master -> FETCH_HEAD * [ new branch ] master -> upstream/master $ git checkout -b patch-1 upstream/master Switched to a new branch 'patch-1'","title":"Setting up your Environment"},{"location":"contributing/contributing/#making-changes","text":"Depending on your changes there are certain rules you have to follow if you expect your Pull Request to be merged. Note : It is recommended to create a new remote branch for each Pull Request based on the current upstream/master changes! Adding a new Method or Class If your addition is not internal (e.g. an impl class or private method) you have to write documentation. For that please follow the JavaDoc template Keep your code consistent! Follow the Structure Guide Compare your code style to the one used all over JDA and ensure you do not break the consistency (if you find issues in the JDA style you can include and update it) Example Bad Addition Good Addition + public void reset() { + name.reset(); + avatar.reset(); + + if (isType(AccountType.CLIENT)) { + email.reset(); + password.reset(); + } + } + /* + * Resets all {@link net.dv8tion.jda.core.managers.fields.AccountField Fields} + * for this manager instance by calling + * {@link net.dv8tion.jda.core.managers.fields.Field#reset() Field.reset()} sequentially + */ + public void reset() + { + name.reset(); + avatar.reset(); + + if (isType(AccountType.CLIENT)) + { + email.reset(); + password.reset(); + } + } Making a Commit While having multiple commits can help the reader understand your changes, it might sometimes be better to include more changes in a single commit. When you commit your changes write a proper commit caption which explains what you have done Updating your Fork Before you start committing make sure your fork is updated. (See Syncing a Fork or Keeping a Fork Updated )","title":"Making Changes"},{"location":"contributing/contributing/#creating-a-pull-request","text":"Commit your changes $ git commit -am \"Updated Copyright in build.gradle\" [ patch-1 340383d ] Updated Copyright in build.gradle 1 file changed, 1 insertion ( + ) , 1 deletion ( - ) Push your commits $ git push origin patch-1 Counting objects: 3 , done . Delta compression using up to 8 threads. Compressing objects: 100 % ( 3 /3 ) , done . Writing objects: 100 % ( 3 /3 ) , 313 bytes | 0 bytes/s, done . Total 3 ( delta 2 ) , reused 0 ( delta 0 ) remote: Resolving deltas: 100 % ( 2 /2 ) , completed with 2 local objects. To https://github.com/ExampleName/JDA.git * [ new branch ] patch-1 -> patch-1 Open Pull-Request Set base branch to base fork: DV8FromTheWorld/JDA base: development (OR base: docs/development ) Allow edits from Maintainers Done! Just click Create pull request and await a review by one of the maintainers!","title":"Creating a Pull Request"},{"location":"contributing/repository-structure/","text":"Repository Structure \u00b6 The structure of the JDA repository is heavily inspired from A Successful Git Branching Model Release Branch \u00b6 This branch represents the latest stable release. If a bug is found that requires immediate handling, a hotfix branch is to be based off of this branch and merged back into it. Release Candidate Branch \u00b6 The release candidate branches are forks of the development branch and are mainly used to prepare a release. The branch name is formatted as release-x where x would be the expected version. Based off: - development Merged into: - development - release Hotfix Branch \u00b6 These branches are used to fix critical issues on the stable release and are to be merged right into master and development. If a release is in the process of being established and clashes versions, the version of the unmerged release is bumped. Based off: - release Merged into: - development - release Development Branch \u00b6 This is the core of the repository where all changes start. All Pull Requests are based off of this branch and merged back into it. Feature Branches should be forked from development and merged back into it. Merged into: - release Documentation Branch \u00b6 This is branch dedicated to updating the documentation. Since we build every change on development , we don't want to do a ton of \"Fix typo\" builds. For this reason we have this documentation branch. Merged into: - development Feature Branch \u00b6 A feature branch should be used to develop a new feature for the library and should only deal with the core of the feature. Feature branches should not introduce breaking changes but may add deprecation. The branch name is formatted as feature/x where x would be the feature topic. Based off: - development Merged into: - development Experimental Branch \u00b6 An experimental branch changes core functionality of the library to a large extent and requires testing. The branch name is formatted as experimental/x where x would be the experiment topic. Based off: - development Merged into: - development","title":"Repository Structure"},{"location":"contributing/repository-structure/#repository-structure","text":"The structure of the JDA repository is heavily inspired from A Successful Git Branching Model","title":"Repository Structure"},{"location":"contributing/repository-structure/#release-branch","text":"This branch represents the latest stable release. If a bug is found that requires immediate handling, a hotfix branch is to be based off of this branch and merged back into it.","title":"Release Branch"},{"location":"contributing/repository-structure/#release-candidate-branch","text":"The release candidate branches are forks of the development branch and are mainly used to prepare a release. The branch name is formatted as release-x where x would be the expected version. Based off: - development Merged into: - development - release","title":"Release Candidate Branch"},{"location":"contributing/repository-structure/#hotfix-branch","text":"These branches are used to fix critical issues on the stable release and are to be merged right into master and development. If a release is in the process of being established and clashes versions, the version of the unmerged release is bumped. Based off: - release Merged into: - development - release","title":"Hotfix Branch"},{"location":"contributing/repository-structure/#development-branch","text":"This is the core of the repository where all changes start. All Pull Requests are based off of this branch and merged back into it. Feature Branches should be forked from development and merged back into it. Merged into: - release","title":"Development Branch"},{"location":"contributing/repository-structure/#documentation-branch","text":"This is branch dedicated to updating the documentation. Since we build every change on development , we don't want to do a ton of \"Fix typo\" builds. For this reason we have this documentation branch. Merged into: - development","title":"Documentation Branch"},{"location":"contributing/repository-structure/#feature-branch","text":"A feature branch should be used to develop a new feature for the library and should only deal with the core of the feature. Feature branches should not introduce breaking changes but may add deprecation. The branch name is formatted as feature/x where x would be the feature topic. Based off: - development Merged into: - development","title":"Feature Branch"},{"location":"contributing/repository-structure/#experimental-branch","text":"An experimental branch changes core functionality of the library to a large extent and requires testing. The branch name is formatted as experimental/x where x would be the experiment topic. Based off: - development Merged into: - development","title":"Experimental Branch"},{"location":"contributing/structure-guide/","text":"How does JDA stay consistent in its code style and structure? \u00b6 On this page we will try to concentrate all structure and code style guides that we ourself use in JDA to ensure consistency and readability. Indentation and Brackets \u00b6 In JDA we use a specific brackets placement that is common for C# development. We put each { curly bracket on its own respective line: Note This rule goes for every curly bracket (open { /close } ) and every scope usage such as try/catch/finally, loops, methods, lambda expressions, class scopes... public void someMethod () { this . works . well (); for ( Each element : from ()) // (1) { System . out . println ( element ); } } Always put a space in-between the scope usage and the opening bracket (i.e. if (true) and not if(true) ) Indentation \u00b6 We only use indentation of 4 spaces consistently throughout JDA. If a Pull Request does not use this indentation we will not accept it. Class Structure \u00b6 In this section we guide you through a logically ordered and structured class under JDA's point of view. Access Modifiers \u00b6 Access Modifiers are the keywords such as public , protected and private . They restrict other members from accessing these fields, methods or classes from locations throughout the library. When trying to order your fields, methods or nested classes we recommend using this logical order: Public Members Protected Members Private Members Package Private Members (no access modifier) In addition it is recommended to always put static fields and methods (not nested classes ) first in your class. Fields marked with the final keyword should come first and should be separated from other fields. For better structure it is suggested to group fields by their declared types. Methods \u00b6 Methods are always defined after fields and the constructor of your class. There are 3 types of methods listed in logical order of appearance: Overriding or Implementing which make use of the @Override tag Internal (impl) setters which can be found in the impl classes of JDA. Object Overrides such as toString , equals and hashCode Nested Classes \u00b6 Nested classes no matter if static or member should always be placed at the very bottom of your class. These include enums and other class types. It is also recommended following the access modifier (see above sections) order here again. Imports and Copyright \u00b6 Every class in JDA has a Copyright Header (see example). Imports use wildcard * when they import 5+ classes from the same package. JavaDoc \u00b6 We put JavaDoc on the following targets: Public Methods that directly confront the JDA user Class level if the specific class has API features that the user can interact with such as an entity or manager Package docs, all not excluded packages require a package-info.java class with proper JavaDoc Paragraphs \u00b6 JDA has a specific JavaDoc structure that is unique to our repository. We use a style in which we encapsulate each important part of the doc in a \"block\" for itself. Each <br> tag is placed in-front of the new line: Note <br> tags are not to be closed /** * This is my first line * <br>And this is my second line */ A new paragraph starts with <p> (not <br><br> !). The <p> tag is supposed to be placed either between the previous and following paragraph or like the <br> tag directly in-front of the first line of that following paragraph: Note Do not close a paragraph tag! It is unnecessary and redundant. /** * Either do this * * <p>Or do this * <p> * You can decide. */ Escaping \u00b6 When you want to use characters that are not available in JavaDoc source most people tend to go with escaped characters such as &tm; . In JDA we usually stick -if possible- to {@literal \u2122} for readability sake. When using this JavaDoc tag you must remember that it does not allow other nested tags since it will replace them with their literal characters instead! Another important tag you can use to achieve something that <code>true</code> does you can use {@code true} . If you however want to also have nested links or other JavaDoc tags in your code snippet you can fallback to using the <code> tag: /** * JDA {@literal >} All others * <br>Because we can do `{@code channel.sendMessage(\"hey\").queue()}` AND `{@code channel.sendMessage(\"hey\").complete()}`! * * <p>Or even do <code>channel.sendMessage(\"hey\").{@link net.dv8tion.jda.core.requests.RestAction#submit submit()}</code>!! */ Note If you are using a tag like this, you have to close it! Linking \u00b6 If the class is not already imported, use the fully qualified name when you are linking to something through JavaDoc! Bad: {@link RestAction} Good: {@link net.dv8tion.jda.core.requests.RestAction RestAction} Note We also highly recommend setting an alias name as you can see in the 2nd example snippet. When you link to an external resource (such as the official API docs) you can use the <a> tag to create a hyperlink. It is recommended to use the target=\"_blank\" tag. Example: <a href=\"https://ci.dv8tion.net/job/JDA\" target=\"_blank\">Download JDA</a> Hint : Sometimes it helps to link other methods in the description and then also including an @see #otherMethod at the very bottom. Case: RestAction return type \u00b6 When your method makes use of RestAction you have to document possible ErrorResponses that can follow from this request: /** * <p>The following {@link net.dv8tion.jda.core.requests.ErrorResponse ErrorResponses} are possible: * <ul> * <li>{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_ACCESS MISSING_ACCESS} * <br>The request was attempted after the account lost access to the * {@link net.dv8tion.jda.core.entities.Guild Guild} or {@link net.dv8tion.jda.client.entities.Group Group} * typically due to being kicked or removed, or after {@link net.dv8tion.jda.core.Permission#MESSAGE_READ Permission.MESSAGE_READ} * was revoked in the {@link net.dv8tion.jda.core.entities.TextChannel TextChannel}</li> * * <li>{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_PERMISSIONS MISSING_PERMISSIONS} * <br>The send request was attempted after the account lost {@link net.dv8tion.jda.core.Permission#MESSAGE_WRITE Permission.MESSAGE_WRITE} in * the {@link net.dv8tion.jda.core.entities.TextChannel TextChannel}.</li> * </ul> */ Note Always make these your last description paragraph Taken from: MessageChannel The @return for simple RestActions is as follows: /** * @return {@link net.dv8tion.jda.core.requests.RestAction RestAction} - Type: String * <br>This is an -optional- description of what this RestAction will provide in case the type isn't enough */ Example Template \u00b6 /** * This description should inform the user about the basic function of the method (or class) * that is being documented. * <br>A line break should be placed at the beginning of the following line. * * <p>This description is optional and should contain additional / notable information about * this method (or class) * * <p>All additional description paragraphs should start with the paragraph tag * at the beginning of the new paragraph and should be separated from the previous * paragraph by (at least) one line. * * <p>The last paragraph should point out what the possible {@link net.dv8tion.jda.core.requests.ErrorResponse ErrorResponses} * are. These can occur in RestAction failures. * <br>For that the following format should be used: * <ul> * <li>{@link net.dv8tion.jda.core.requests.ErrorResponse#UNKNOWN_MESSAGE UNKNOWN_MESSAGE} * <br>The Message did not exist (possibly deleted)</li> * * <li>{@link net.dv8tion.jda.core.requests.ErrorResponse#INVALID_PIN INVALID_PIN} * <br>The message specified can not be pinned (possibly a system message)</li> * * <li>{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_PERMISSIONS MISSING_PERMISSIONS} * <br>This can be caused if we do not hold one of the following Permissions: * <ul> * <li>{@link net.dv8tion.jda.core.Permission#MESSAGE_WRITE MESSAGE_WRITE} * <br>We are unable to send a message to this channel</li> * * <li>{@link net.dv8tion.jda.core.Permission#MESSAGE_READ MESSAGE_READ} * <br>We are unable to read messages in this channel</li> * </ul></li> * </ul> * * @param var0 (1) * The Description should be at the same level as the parameter name * @param var1 * Multiple parameters are to be documented in one \"block\" * * @throws javax.security.auth.login.LoginException * The same goes for descriptions of throwables * @throws net.dv8tion.jda.core.exceptions.RateLimitedException * Multiple throwables are to be documented in one \"block\" * * @return {@link net.dv8tion.jda.core.requests.RestAction RestAction} - Type: {@link net.dv8tion.jda.core.entities.Role Role} * <br>The response type of the RestAction can be described further here. * * @see Void * @see net.dv8tion.jda.core.JDA * * @since 3.0 * * @serialData * If a tag is not specified here it should be at the bottom of the documentation. * <br>If the tag name is too long to follow the proper indentation formatting * it should start the block in the next line with the correct indentation. */ We align each block with whitespace as you can see how @param is separated with 2 space characters from the actual parameter name","title":"Structure Guide"},{"location":"contributing/structure-guide/#how-does-jda-stay-consistent-in-its-code-style-and-structure","text":"On this page we will try to concentrate all structure and code style guides that we ourself use in JDA to ensure consistency and readability.","title":"How does JDA stay consistent in its code style and structure?"},{"location":"contributing/structure-guide/#indentation-and-brackets","text":"In JDA we use a specific brackets placement that is common for C# development. We put each { curly bracket on its own respective line: Note This rule goes for every curly bracket (open { /close } ) and every scope usage such as try/catch/finally, loops, methods, lambda expressions, class scopes... public void someMethod () { this . works . well (); for ( Each element : from ()) // (1) { System . out . println ( element ); } } Always put a space in-between the scope usage and the opening bracket (i.e. if (true) and not if(true) )","title":"Indentation and Brackets"},{"location":"contributing/structure-guide/#indentation","text":"We only use indentation of 4 spaces consistently throughout JDA. If a Pull Request does not use this indentation we will not accept it.","title":"Indentation"},{"location":"contributing/structure-guide/#class-structure","text":"In this section we guide you through a logically ordered and structured class under JDA's point of view.","title":"Class Structure"},{"location":"contributing/structure-guide/#access-modifiers","text":"Access Modifiers are the keywords such as public , protected and private . They restrict other members from accessing these fields, methods or classes from locations throughout the library. When trying to order your fields, methods or nested classes we recommend using this logical order: Public Members Protected Members Private Members Package Private Members (no access modifier) In addition it is recommended to always put static fields and methods (not nested classes ) first in your class. Fields marked with the final keyword should come first and should be separated from other fields. For better structure it is suggested to group fields by their declared types.","title":"Access Modifiers"},{"location":"contributing/structure-guide/#methods","text":"Methods are always defined after fields and the constructor of your class. There are 3 types of methods listed in logical order of appearance: Overriding or Implementing which make use of the @Override tag Internal (impl) setters which can be found in the impl classes of JDA. Object Overrides such as toString , equals and hashCode","title":"Methods"},{"location":"contributing/structure-guide/#nested-classes","text":"Nested classes no matter if static or member should always be placed at the very bottom of your class. These include enums and other class types. It is also recommended following the access modifier (see above sections) order here again.","title":"Nested Classes"},{"location":"contributing/structure-guide/#imports-and-copyright","text":"Every class in JDA has a Copyright Header (see example). Imports use wildcard * when they import 5+ classes from the same package.","title":"Imports and Copyright"},{"location":"contributing/structure-guide/#javadoc","text":"We put JavaDoc on the following targets: Public Methods that directly confront the JDA user Class level if the specific class has API features that the user can interact with such as an entity or manager Package docs, all not excluded packages require a package-info.java class with proper JavaDoc","title":"JavaDoc"},{"location":"contributing/structure-guide/#paragraphs","text":"JDA has a specific JavaDoc structure that is unique to our repository. We use a style in which we encapsulate each important part of the doc in a \"block\" for itself. Each <br> tag is placed in-front of the new line: Note <br> tags are not to be closed /** * This is my first line * <br>And this is my second line */ A new paragraph starts with <p> (not <br><br> !). The <p> tag is supposed to be placed either between the previous and following paragraph or like the <br> tag directly in-front of the first line of that following paragraph: Note Do not close a paragraph tag! It is unnecessary and redundant. /** * Either do this * * <p>Or do this * <p> * You can decide. */","title":"Paragraphs"},{"location":"contributing/structure-guide/#escaping","text":"When you want to use characters that are not available in JavaDoc source most people tend to go with escaped characters such as &tm; . In JDA we usually stick -if possible- to {@literal \u2122} for readability sake. When using this JavaDoc tag you must remember that it does not allow other nested tags since it will replace them with their literal characters instead! Another important tag you can use to achieve something that <code>true</code> does you can use {@code true} . If you however want to also have nested links or other JavaDoc tags in your code snippet you can fallback to using the <code> tag: /** * JDA {@literal >} All others * <br>Because we can do `{@code channel.sendMessage(\"hey\").queue()}` AND `{@code channel.sendMessage(\"hey\").complete()}`! * * <p>Or even do <code>channel.sendMessage(\"hey\").{@link net.dv8tion.jda.core.requests.RestAction#submit submit()}</code>!! */ Note If you are using a tag like this, you have to close it!","title":"Escaping"},{"location":"contributing/structure-guide/#linking","text":"If the class is not already imported, use the fully qualified name when you are linking to something through JavaDoc! Bad: {@link RestAction} Good: {@link net.dv8tion.jda.core.requests.RestAction RestAction} Note We also highly recommend setting an alias name as you can see in the 2nd example snippet. When you link to an external resource (such as the official API docs) you can use the <a> tag to create a hyperlink. It is recommended to use the target=\"_blank\" tag. Example: <a href=\"https://ci.dv8tion.net/job/JDA\" target=\"_blank\">Download JDA</a> Hint : Sometimes it helps to link other methods in the description and then also including an @see #otherMethod at the very bottom.","title":"Linking"},{"location":"contributing/structure-guide/#case-restaction-return-type","text":"When your method makes use of RestAction you have to document possible ErrorResponses that can follow from this request: /** * <p>The following {@link net.dv8tion.jda.core.requests.ErrorResponse ErrorResponses} are possible: * <ul> * <li>{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_ACCESS MISSING_ACCESS} * <br>The request was attempted after the account lost access to the * {@link net.dv8tion.jda.core.entities.Guild Guild} or {@link net.dv8tion.jda.client.entities.Group Group} * typically due to being kicked or removed, or after {@link net.dv8tion.jda.core.Permission#MESSAGE_READ Permission.MESSAGE_READ} * was revoked in the {@link net.dv8tion.jda.core.entities.TextChannel TextChannel}</li> * * <li>{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_PERMISSIONS MISSING_PERMISSIONS} * <br>The send request was attempted after the account lost {@link net.dv8tion.jda.core.Permission#MESSAGE_WRITE Permission.MESSAGE_WRITE} in * the {@link net.dv8tion.jda.core.entities.TextChannel TextChannel}.</li> * </ul> */ Note Always make these your last description paragraph Taken from: MessageChannel The @return for simple RestActions is as follows: /** * @return {@link net.dv8tion.jda.core.requests.RestAction RestAction} - Type: String * <br>This is an -optional- description of what this RestAction will provide in case the type isn't enough */","title":"Case: RestAction return type"},{"location":"contributing/structure-guide/#example-template","text":"/** * This description should inform the user about the basic function of the method (or class) * that is being documented. * <br>A line break should be placed at the beginning of the following line. * * <p>This description is optional and should contain additional / notable information about * this method (or class) * * <p>All additional description paragraphs should start with the paragraph tag * at the beginning of the new paragraph and should be separated from the previous * paragraph by (at least) one line. * * <p>The last paragraph should point out what the possible {@link net.dv8tion.jda.core.requests.ErrorResponse ErrorResponses} * are. These can occur in RestAction failures. * <br>For that the following format should be used: * <ul> * <li>{@link net.dv8tion.jda.core.requests.ErrorResponse#UNKNOWN_MESSAGE UNKNOWN_MESSAGE} * <br>The Message did not exist (possibly deleted)</li> * * <li>{@link net.dv8tion.jda.core.requests.ErrorResponse#INVALID_PIN INVALID_PIN} * <br>The message specified can not be pinned (possibly a system message)</li> * * <li>{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_PERMISSIONS MISSING_PERMISSIONS} * <br>This can be caused if we do not hold one of the following Permissions: * <ul> * <li>{@link net.dv8tion.jda.core.Permission#MESSAGE_WRITE MESSAGE_WRITE} * <br>We are unable to send a message to this channel</li> * * <li>{@link net.dv8tion.jda.core.Permission#MESSAGE_READ MESSAGE_READ} * <br>We are unable to read messages in this channel</li> * </ul></li> * </ul> * * @param var0 (1) * The Description should be at the same level as the parameter name * @param var1 * Multiple parameters are to be documented in one \"block\" * * @throws javax.security.auth.login.LoginException * The same goes for descriptions of throwables * @throws net.dv8tion.jda.core.exceptions.RateLimitedException * Multiple throwables are to be documented in one \"block\" * * @return {@link net.dv8tion.jda.core.requests.RestAction RestAction} - Type: {@link net.dv8tion.jda.core.entities.Role Role} * <br>The response type of the RestAction can be described further here. * * @see Void * @see net.dv8tion.jda.core.JDA * * @since 3.0 * * @serialData * If a tag is not specified here it should be at the bottom of the documentation. * <br>If the tag name is too long to follow the proper indentation formatting * it should start the block in the next line with the correct indentation. */ We align each block with whitespace as you can see how @param is separated with 2 space characters from the actual parameter name","title":"Example Template"},{"location":"introduction/events-list/","text":"List of Events \u00b6 All events mentioned in this list are a sub-type of GenericEvent JDA Events \u00b6 GenericEvent \u251c\u2500\u2500 DisconnectEvent \u251c\u2500\u2500 ExceptionEvent \u251c\u2500\u2500 ReadyEvent \u251c\u2500\u2500 ResumedEvent \u251c\u2500\u2500 ReconnectedEvent \u251c\u2500\u2500 ShutdownEvent \u251c\u2500\u2500 StatusChangeEvent (1) \u251c\u2500\u2500 HttpRequestEvent \u251c\u2500\u2500 RawGatewayEvent (2) \u251c\u2500\u2500 GatewayPingEvent \u251c\u2500\u2500 MessageBulkDeleteEvent (2) \u251c\u2500\u2500 UnavailableGuildJoinedEvent \u251c\u2500\u2500 UnavailableGuildLeaveEvent \u2514\u2500\u2500 UpdateEvent Self Events \u00b6 Fires only in relation to the currently logged in account. GenericSelfUpdateEvent (1) \u251c\u2500\u2500 SelfUpdateAvatarEvent \u251c\u2500\u2500 SelfUpdateDiscriminatorEvent \u251c\u2500\u2500 SelfUpdateMFAEvent \u251c\u2500\u2500 SelfUpdateNameEvent \u2514\u2500\u2500 SelfUpdateVerifiedEvent User Events \u00b6 GenericUserEvent \u251c\u2500\u2500 GenericUserUpdateEvent (1) \u2502 \u251c\u2500\u2500 UserUpdateOnlineStatusEvent (3) | \u251c\u2500\u2500 UserUpdateActivityOrderEvent (3) \u2502 \u251c\u2500\u2500 UserUpdateActivitiesEvent (3) \u2502 \u251c\u2500\u2500 UserUpdateAvatarEvent \u2502 \u251c\u2500\u2500 UserUpdateDiscriminatorEvent \u2502 \u251c\u2500\u2500 UserUpdateFlagsEvent \u2502 \u2514\u2500\u2500 UserUpdateNameEvent \u251c\u2500\u2500 UserActivityStartEvent (3) \u251c\u2500\u2500 UserActivityEndEvent (3) \u2514\u2500\u2500 UserTypingEvent Message Events \u00b6 GenericMessageEvent \u251c\u2500\u2500 MessageDeleteEvent \u251c\u2500\u2500 MessageEmbedEvent \u251c\u2500\u2500 MessageReceivedEvent \u251c\u2500\u2500 MessageUpdateEvent \u251c\u2500\u2500 MessageReactionRemoveAllEvent \u251c\u2500\u2500 MessageReactionRemoveEmojiEvent \u2514\u2500\u2500 GenericMessageReactionEvent \u251c\u2500\u2500 MessageReactionAddEvent \u2514\u2500\u2500 MessageReactionRemoveEvent MessageBulkDeleteEvent is a special event and does not extend GenericMessageEvent ! Guild Events \u00b6 GenericGuildEvent \u251c\u2500\u2500 GuildReadyEvent \u251c\u2500\u2500 GuildAvailableEvent \u251c\u2500\u2500 GuildUnavailableEvent \u251c\u2500\u2500 GuildJoinEvent \u251c\u2500\u2500 GuildLeaveEvent \u251c\u2500\u2500 GuildBanEvent \u251c\u2500\u2500 GuildUnbanEvent \u251c\u2500\u2500 GuildMemberRemoveEvent \u251c\u2500\u2500 GenericGuildInviteEvent \u2502 \u251c\u2500\u2500 GuildInviteCreateEvent \u2502 \u2514\u2500\u2500 GuildInviteDeleteEvent \u251c\u2500\u2500 GenericPermissionOverrideEvent \u2502 \u251c\u2500\u2500 PermissionOverrideCreateEvent \u2502 \u251c\u2500\u2500 PermissionOverrideDeleteEvent \u2502 \u2514\u2500\u2500 PermissionOverrideUpdateEvent \u251c\u2500\u2500 GenericStageInstanceEvent \u2502 \u251c\u2500\u2500 StageInstanceCreateEvent \u2502 \u251c\u2500\u2500 StageInstanceDeleteEvent \u2502 \u2514\u2500\u2500 GenericStageInstanceUpdateEvent (1) \u2502 \u251c\u2500\u2500 StageInstanceUpdatePrivacyLevelEvent | \u2514\u2500\u2500 StageInstanceUpdateTopicEvent \u251c\u2500\u2500 GenericGuildUpdateEvent (1) \u2502 \u251c\u2500\u2500 GuildUpdateAfkChannelEvent \u2502 \u251c\u2500\u2500 GuildUpdateAfkTimeoutEvent \u2502 \u251c\u2500\u2500 GuildUpdateExplicitContentLevelEvent \u2502 \u251c\u2500\u2500 GuildUpdateFeaturesEvent \u2502 \u251c\u2500\u2500 GuildUpdateIconEvent \u2502 \u251c\u2500\u2500 GuildUpdateMFALevelEvent \u2502 \u251c\u2500\u2500 GuildUpdateNameEvent \u2502 \u251c\u2500\u2500 GuildUpdateNotificationLevelEvent \u2502 \u251c\u2500\u2500 GuildUpdateOwnerEvent \u2502 \u251c\u2500\u2500 GuildUpdateSplashEvent \u2502 \u251c\u2500\u2500 GuildUpdateSystemChannelEvent \u2502 \u251c\u2500\u2500 GuildUpdateBannerEvent \u2502 \u251c\u2500\u2500 GuildUpdateBoostCountEvent \u2502 \u251c\u2500\u2500 GuildUpdateBoostTierEvent \u2502 \u251c\u2500\u2500 GuildUpdateDescriptionEvent \u2502 \u251c\u2500\u2500 GuildUpdateMaxMembersEvent \u2502 \u251c\u2500\u2500 GuildUpdateMaxPresencesEvent \u2502 \u251c\u2500\u2500 GuildUpdateVanityCodeEvent \u2502 \u251c\u2500\u2500 GuildUpdateCommunityUpdatesChannelEvent \u2502 \u251c\u2500\u2500 GuildUpdateLocaleEvent \u2502 \u251c\u2500\u2500 GuildUpdateNSFWLevelEvent \u2502 \u251c\u2500\u2500 GuildUpdateRulesChannelEvent \u2502 \u2514\u2500\u2500 GuildUpdateVerificationLevelEvent \u251c\u2500\u2500 GenericGuildMemberEvent \u2502 \u251c\u2500\u2500 GuildMemberJoinEvent \u2502 \u251c\u2500\u2500 GuildMemberRoleAddEvent \u2502 \u251c\u2500\u2500 GuildMemberRoleRemoveEvent \u2502 \u251c\u2500\u2500 GuildMemberUpdateEvent \u2502 \u2514\u2500\u2500 GenericGuildMemberUpdateEvent (1) \u2502 \u251c\u2500\u2500 GuildMemberUpdateNicknameEvent \u2502 \u251c\u2500\u2500 GuildMemberUpdateAvatarEvent \u2502 \u251c\u2500\u2500 GuildMemberUpdatePendingEvent | \u251c\u2500\u2500 GuildMemberUpdateTimeOutEvent \u2502 \u2514\u2500\u2500 GuildMemberUpdateBoostTimeEvent \u2514\u2500\u2500 GenericGuildVoiceEvent \u251c\u2500\u2500 GuildVoiceDeafenEvent \u251c\u2500\u2500 GuildVoiceGuildDeafenEvent \u251c\u2500\u2500 GuildVoiceGuildMuteEvent \u251c\u2500\u2500 GuildVoiceMuteEvent \u251c\u2500\u2500 GuildVoiceSelfDeafenEvent \u251c\u2500\u2500 GuildVoiceSelfMuteEvent \u251c\u2500\u2500 GuildVoiceStreamEvent \u251c\u2500\u2500 GuildVoiceRequestToSpeakEvent \u251c\u2500\u2500 GuildVoiceVideoEvent \u251c\u2500\u2500 GuildVoiceSuppressEvent \u2514\u2500\u2500 GuildVoiceUpdateEvent (1) \u251c\u2500\u2500 GuildVoiceJoinEvent \u251c\u2500\u2500 GuildVoiceLeaveEvent \u2514\u2500\u2500 GuildVoiceMoveEvent UnavailableGuildJoinedEvent and UnavailableGuildLeaveEvent are special events and do not extend GenericGuildEvent ! Channel Events \u00b6 GenericChannelEvent \u251c\u2500\u2500 ChannelCreateEvent \u251c\u2500\u2500 ChannelDeleteEvent \u2514\u2500\u2500 GenericChannelUpdateEvent (1) \u251c\u2500\u2500 ChannelUpdateArchivedEvent \u251c\u2500\u2500 ChannelUpdateArchiveTimestampEvent \u251c\u2500\u2500 ChannelUpdateAutoArchiveDurationEvent \u251c\u2500\u2500 ChannelUpdateBitrateEvent \u251c\u2500\u2500 ChannelUpdateInvitableEvent \u251c\u2500\u2500 ChannelUpdateLockedEvent \u251c\u2500\u2500 ChannelUpdateNameEvent \u251c\u2500\u2500 ChannelUpdateNSFWEvent \u251c\u2500\u2500 ChannelUpdateParentEvent \u251c\u2500\u2500 ChannelUpdatePositionEvent \u251c\u2500\u2500 ChannelUpdateRegionEvent \u251c\u2500\u2500 ChannelUpdateSlowmodeEvent \u251c\u2500\u2500 ChannelUpdateTopicEvent \u251c\u2500\u2500 ChannelUpdateTypeEvent \u2514\u2500\u2500 ChannelUpdateUserLimitEvent Role Events \u00b6 GenericRoleEvent \u251c\u2500\u2500 RoleCreateEvent \u251c\u2500\u2500 RoleDeleteEvent \u2514\u2500\u2500 GenericRoleUpdateEvent (1) \u251c\u2500\u2500 RoleUpdateColorEvent \u251c\u2500\u2500 RoleUpdateHoistedEvent \u251c\u2500\u2500 RoleUpdateMentionableEvent \u251c\u2500\u2500 RoleUpdateNameEvent \u251c\u2500\u2500 RoleUpdatePermissionsEvent \u251c\u2500\u2500 RoleUpdateIconEvent \u2514\u2500\u2500 RoleUpdatePositionEvent Emoji Events \u00b6 GenericEmojiEvent \u251c\u2500\u2500 EmojiAddedEvent \u251c\u2500\u2500 EmojiRemovedEvent \u2514\u2500\u2500 GenericEmojiUpdateEvent (1) \u251c\u2500\u2500 EmojiUpdateNameEvent \u2514\u2500\u2500 EmojiUpdateRolesEvent Sticker Events \u00b6 GenericGuildStickerEvent \u251c\u2500\u2500 GuildStickerAddedEvent \u251c\u2500\u2500 GuildStickerRemovedEvent \u2514\u2500\u2500 GenericGuildStickerUpdateEvent (1) \u251c\u2500\u2500 GuildStickerUpdateAvailableEvent \u251c\u2500\u2500 GuildStickerUpdateDescriptionEvent \u251c\u2500\u2500 GuildStickerUpdateNameEvent \u2514\u2500\u2500 GuildStickerUpdateTagsEvent This extends UpdateEvent \u21a9 This event needs to be explicitly enabled in the JDABuilder/DefaultShardManagerBuilder \u21a9 This extends GenericUserPresenceEvent \u21a9","title":"List of Events"},{"location":"introduction/events-list/#list-of-events","text":"All events mentioned in this list are a sub-type of GenericEvent","title":"List of Events"},{"location":"introduction/events-list/#jda-events","text":"GenericEvent \u251c\u2500\u2500 DisconnectEvent \u251c\u2500\u2500 ExceptionEvent \u251c\u2500\u2500 ReadyEvent \u251c\u2500\u2500 ResumedEvent \u251c\u2500\u2500 ReconnectedEvent \u251c\u2500\u2500 ShutdownEvent \u251c\u2500\u2500 StatusChangeEvent (1) \u251c\u2500\u2500 HttpRequestEvent \u251c\u2500\u2500 RawGatewayEvent (2) \u251c\u2500\u2500 GatewayPingEvent \u251c\u2500\u2500 MessageBulkDeleteEvent (2) \u251c\u2500\u2500 UnavailableGuildJoinedEvent \u251c\u2500\u2500 UnavailableGuildLeaveEvent \u2514\u2500\u2500 UpdateEvent","title":"JDA Events"},{"location":"introduction/events-list/#self-events","text":"Fires only in relation to the currently logged in account. GenericSelfUpdateEvent (1) \u251c\u2500\u2500 SelfUpdateAvatarEvent \u251c\u2500\u2500 SelfUpdateDiscriminatorEvent \u251c\u2500\u2500 SelfUpdateMFAEvent \u251c\u2500\u2500 SelfUpdateNameEvent \u2514\u2500\u2500 SelfUpdateVerifiedEvent","title":"Self Events"},{"location":"introduction/events-list/#user-events","text":"GenericUserEvent \u251c\u2500\u2500 GenericUserUpdateEvent (1) \u2502 \u251c\u2500\u2500 UserUpdateOnlineStatusEvent (3) | \u251c\u2500\u2500 UserUpdateActivityOrderEvent (3) \u2502 \u251c\u2500\u2500 UserUpdateActivitiesEvent (3) \u2502 \u251c\u2500\u2500 UserUpdateAvatarEvent \u2502 \u251c\u2500\u2500 UserUpdateDiscriminatorEvent \u2502 \u251c\u2500\u2500 UserUpdateFlagsEvent \u2502 \u2514\u2500\u2500 UserUpdateNameEvent \u251c\u2500\u2500 UserActivityStartEvent (3) \u251c\u2500\u2500 UserActivityEndEvent (3) \u2514\u2500\u2500 UserTypingEvent","title":"User Events"},{"location":"introduction/events-list/#message-events","text":"GenericMessageEvent \u251c\u2500\u2500 MessageDeleteEvent \u251c\u2500\u2500 MessageEmbedEvent \u251c\u2500\u2500 MessageReceivedEvent \u251c\u2500\u2500 MessageUpdateEvent \u251c\u2500\u2500 MessageReactionRemoveAllEvent \u251c\u2500\u2500 MessageReactionRemoveEmojiEvent \u2514\u2500\u2500 GenericMessageReactionEvent \u251c\u2500\u2500 MessageReactionAddEvent \u2514\u2500\u2500 MessageReactionRemoveEvent MessageBulkDeleteEvent is a special event and does not extend GenericMessageEvent !","title":"Message Events"},{"location":"introduction/events-list/#guild-events","text":"GenericGuildEvent \u251c\u2500\u2500 GuildReadyEvent \u251c\u2500\u2500 GuildAvailableEvent \u251c\u2500\u2500 GuildUnavailableEvent \u251c\u2500\u2500 GuildJoinEvent \u251c\u2500\u2500 GuildLeaveEvent \u251c\u2500\u2500 GuildBanEvent \u251c\u2500\u2500 GuildUnbanEvent \u251c\u2500\u2500 GuildMemberRemoveEvent \u251c\u2500\u2500 GenericGuildInviteEvent \u2502 \u251c\u2500\u2500 GuildInviteCreateEvent \u2502 \u2514\u2500\u2500 GuildInviteDeleteEvent \u251c\u2500\u2500 GenericPermissionOverrideEvent \u2502 \u251c\u2500\u2500 PermissionOverrideCreateEvent \u2502 \u251c\u2500\u2500 PermissionOverrideDeleteEvent \u2502 \u2514\u2500\u2500 PermissionOverrideUpdateEvent \u251c\u2500\u2500 GenericStageInstanceEvent \u2502 \u251c\u2500\u2500 StageInstanceCreateEvent \u2502 \u251c\u2500\u2500 StageInstanceDeleteEvent \u2502 \u2514\u2500\u2500 GenericStageInstanceUpdateEvent (1) \u2502 \u251c\u2500\u2500 StageInstanceUpdatePrivacyLevelEvent | \u2514\u2500\u2500 StageInstanceUpdateTopicEvent \u251c\u2500\u2500 GenericGuildUpdateEvent (1) \u2502 \u251c\u2500\u2500 GuildUpdateAfkChannelEvent \u2502 \u251c\u2500\u2500 GuildUpdateAfkTimeoutEvent \u2502 \u251c\u2500\u2500 GuildUpdateExplicitContentLevelEvent \u2502 \u251c\u2500\u2500 GuildUpdateFeaturesEvent \u2502 \u251c\u2500\u2500 GuildUpdateIconEvent \u2502 \u251c\u2500\u2500 GuildUpdateMFALevelEvent \u2502 \u251c\u2500\u2500 GuildUpdateNameEvent \u2502 \u251c\u2500\u2500 GuildUpdateNotificationLevelEvent \u2502 \u251c\u2500\u2500 GuildUpdateOwnerEvent \u2502 \u251c\u2500\u2500 GuildUpdateSplashEvent \u2502 \u251c\u2500\u2500 GuildUpdateSystemChannelEvent \u2502 \u251c\u2500\u2500 GuildUpdateBannerEvent \u2502 \u251c\u2500\u2500 GuildUpdateBoostCountEvent \u2502 \u251c\u2500\u2500 GuildUpdateBoostTierEvent \u2502 \u251c\u2500\u2500 GuildUpdateDescriptionEvent \u2502 \u251c\u2500\u2500 GuildUpdateMaxMembersEvent \u2502 \u251c\u2500\u2500 GuildUpdateMaxPresencesEvent \u2502 \u251c\u2500\u2500 GuildUpdateVanityCodeEvent \u2502 \u251c\u2500\u2500 GuildUpdateCommunityUpdatesChannelEvent \u2502 \u251c\u2500\u2500 GuildUpdateLocaleEvent \u2502 \u251c\u2500\u2500 GuildUpdateNSFWLevelEvent \u2502 \u251c\u2500\u2500 GuildUpdateRulesChannelEvent \u2502 \u2514\u2500\u2500 GuildUpdateVerificationLevelEvent \u251c\u2500\u2500 GenericGuildMemberEvent \u2502 \u251c\u2500\u2500 GuildMemberJoinEvent \u2502 \u251c\u2500\u2500 GuildMemberRoleAddEvent \u2502 \u251c\u2500\u2500 GuildMemberRoleRemoveEvent \u2502 \u251c\u2500\u2500 GuildMemberUpdateEvent \u2502 \u2514\u2500\u2500 GenericGuildMemberUpdateEvent (1) \u2502 \u251c\u2500\u2500 GuildMemberUpdateNicknameEvent \u2502 \u251c\u2500\u2500 GuildMemberUpdateAvatarEvent \u2502 \u251c\u2500\u2500 GuildMemberUpdatePendingEvent | \u251c\u2500\u2500 GuildMemberUpdateTimeOutEvent \u2502 \u2514\u2500\u2500 GuildMemberUpdateBoostTimeEvent \u2514\u2500\u2500 GenericGuildVoiceEvent \u251c\u2500\u2500 GuildVoiceDeafenEvent \u251c\u2500\u2500 GuildVoiceGuildDeafenEvent \u251c\u2500\u2500 GuildVoiceGuildMuteEvent \u251c\u2500\u2500 GuildVoiceMuteEvent \u251c\u2500\u2500 GuildVoiceSelfDeafenEvent \u251c\u2500\u2500 GuildVoiceSelfMuteEvent \u251c\u2500\u2500 GuildVoiceStreamEvent \u251c\u2500\u2500 GuildVoiceRequestToSpeakEvent \u251c\u2500\u2500 GuildVoiceVideoEvent \u251c\u2500\u2500 GuildVoiceSuppressEvent \u2514\u2500\u2500 GuildVoiceUpdateEvent (1) \u251c\u2500\u2500 GuildVoiceJoinEvent \u251c\u2500\u2500 GuildVoiceLeaveEvent \u2514\u2500\u2500 GuildVoiceMoveEvent UnavailableGuildJoinedEvent and UnavailableGuildLeaveEvent are special events and do not extend GenericGuildEvent !","title":"Guild Events"},{"location":"introduction/events-list/#channel-events","text":"GenericChannelEvent \u251c\u2500\u2500 ChannelCreateEvent \u251c\u2500\u2500 ChannelDeleteEvent \u2514\u2500\u2500 GenericChannelUpdateEvent (1) \u251c\u2500\u2500 ChannelUpdateArchivedEvent \u251c\u2500\u2500 ChannelUpdateArchiveTimestampEvent \u251c\u2500\u2500 ChannelUpdateAutoArchiveDurationEvent \u251c\u2500\u2500 ChannelUpdateBitrateEvent \u251c\u2500\u2500 ChannelUpdateInvitableEvent \u251c\u2500\u2500 ChannelUpdateLockedEvent \u251c\u2500\u2500 ChannelUpdateNameEvent \u251c\u2500\u2500 ChannelUpdateNSFWEvent \u251c\u2500\u2500 ChannelUpdateParentEvent \u251c\u2500\u2500 ChannelUpdatePositionEvent \u251c\u2500\u2500 ChannelUpdateRegionEvent \u251c\u2500\u2500 ChannelUpdateSlowmodeEvent \u251c\u2500\u2500 ChannelUpdateTopicEvent \u251c\u2500\u2500 ChannelUpdateTypeEvent \u2514\u2500\u2500 ChannelUpdateUserLimitEvent","title":"Channel Events"},{"location":"introduction/events-list/#role-events","text":"GenericRoleEvent \u251c\u2500\u2500 RoleCreateEvent \u251c\u2500\u2500 RoleDeleteEvent \u2514\u2500\u2500 GenericRoleUpdateEvent (1) \u251c\u2500\u2500 RoleUpdateColorEvent \u251c\u2500\u2500 RoleUpdateHoistedEvent \u251c\u2500\u2500 RoleUpdateMentionableEvent \u251c\u2500\u2500 RoleUpdateNameEvent \u251c\u2500\u2500 RoleUpdatePermissionsEvent \u251c\u2500\u2500 RoleUpdateIconEvent \u2514\u2500\u2500 RoleUpdatePositionEvent","title":"Role Events"},{"location":"introduction/events-list/#emoji-events","text":"GenericEmojiEvent \u251c\u2500\u2500 EmojiAddedEvent \u251c\u2500\u2500 EmojiRemovedEvent \u2514\u2500\u2500 GenericEmojiUpdateEvent (1) \u251c\u2500\u2500 EmojiUpdateNameEvent \u2514\u2500\u2500 EmojiUpdateRolesEvent","title":"Emoji Events"},{"location":"introduction/events-list/#sticker-events","text":"GenericGuildStickerEvent \u251c\u2500\u2500 GuildStickerAddedEvent \u251c\u2500\u2500 GuildStickerRemovedEvent \u2514\u2500\u2500 GenericGuildStickerUpdateEvent (1) \u251c\u2500\u2500 GuildStickerUpdateAvailableEvent \u251c\u2500\u2500 GuildStickerUpdateDescriptionEvent \u251c\u2500\u2500 GuildStickerUpdateNameEvent \u2514\u2500\u2500 GuildStickerUpdateTagsEvent This extends UpdateEvent \u21a9 This event needs to be explicitly enabled in the JDABuilder/DefaultShardManagerBuilder \u21a9 This extends GenericUserPresenceEvent \u21a9","title":"Sticker Events"},{"location":"introduction/events/","text":"Using Events \u00b6 Registering your Listener \u00b6 To register your listener, we currently have 2 Systems. Annotated Listeners (AnnotatedEventManager) and Listeners implementing the Interface EventListener (InterfacedEventManager) . By default, the Interfaced one is used. To switch between them, you can either use JDABuilder#setEventManager(new AnnotatedEventManager()) , or JDA#setEventManager(new MyEventManager()) . After that, you just need to call JDABuilder#addEventListeners(Object...) or JDA#addEventListeners(Object...) with your Listener implementation. Using JDABuilder // imports {...} public class Launcher { public static void main ( String [] arguments ) throws LoginException , InterruptedException { JDA api = JDABuilder . createDefault ( arguments [ 0 ] ) . addEventListeners ( new PingPongBot ()) . build (). awaitReady (); } } Using JDA // imports {...} public class MyListeners { public static void registerPingPongListener ( JDA api ) { api . addEventListeners ( new PingPongBot ()); } } Using the Interfaced System (default) \u00b6 When using the interfaced system (default), your Listener(s) have to implement the Interface EventListener , which only has a single function to implement: public void onEvent(GenericEvent event) . For convenience, we also included the class ListenerAdapter , which comes with a wide set of predefined functions targeted at specific event-types. Examples Using EventListener public class Test implements EventListener { @Override public void onEvent ( GenericEvent event ) { if ( event instanceof MessageReceivedEvent ) System . out . println ( event . getMessage (). getContentDisplay ()); } } Using ListenerAdapter public class Test extends ListenerAdapter { @Override public void onMessageReceived ( MessageReceivedEvent event ) { System . out . println ( event . getMessage (). getContentDisplay ()); } } Don't forget actually registering this listener Using the Annotated System \u00b6 When using the annotated system, all listener methods have to have the @SubscribeEvent annotation present, and only accept a single parameter, which has to be a instance of Event . Example public class Test { public static void main ( String [] args ) throws LoginException { JDABuilder . createDefault ( TOKEN ) . setEventManager ( new AnnotatedEventManager ()) . addEventListeners ( new Test ()) . build (); } @SubscribeEvent public void ohHeyAMessage ( MessageReceivedEvent event ) { System . out . println ( event . getMessage (). getContentDisplay ()); } } Don't forget actually registering this listener","title":"Using Events"},{"location":"introduction/events/#using-events","text":"","title":"Using Events"},{"location":"introduction/events/#registering-your-listener","text":"To register your listener, we currently have 2 Systems. Annotated Listeners (AnnotatedEventManager) and Listeners implementing the Interface EventListener (InterfacedEventManager) . By default, the Interfaced one is used. To switch between them, you can either use JDABuilder#setEventManager(new AnnotatedEventManager()) , or JDA#setEventManager(new MyEventManager()) . After that, you just need to call JDABuilder#addEventListeners(Object...) or JDA#addEventListeners(Object...) with your Listener implementation. Using JDABuilder // imports {...} public class Launcher { public static void main ( String [] arguments ) throws LoginException , InterruptedException { JDA api = JDABuilder . createDefault ( arguments [ 0 ] ) . addEventListeners ( new PingPongBot ()) . build (). awaitReady (); } } Using JDA // imports {...} public class MyListeners { public static void registerPingPongListener ( JDA api ) { api . addEventListeners ( new PingPongBot ()); } }","title":"Registering your Listener"},{"location":"introduction/events/#using-the-interfaced-system-default","text":"When using the interfaced system (default), your Listener(s) have to implement the Interface EventListener , which only has a single function to implement: public void onEvent(GenericEvent event) . For convenience, we also included the class ListenerAdapter , which comes with a wide set of predefined functions targeted at specific event-types. Examples Using EventListener public class Test implements EventListener { @Override public void onEvent ( GenericEvent event ) { if ( event instanceof MessageReceivedEvent ) System . out . println ( event . getMessage (). getContentDisplay ()); } } Using ListenerAdapter public class Test extends ListenerAdapter { @Override public void onMessageReceived ( MessageReceivedEvent event ) { System . out . println ( event . getMessage (). getContentDisplay ()); } } Don't forget actually registering this listener","title":"Using the Interfaced System (default)"},{"location":"introduction/events/#using-the-annotated-system","text":"When using the annotated system, all listener methods have to have the @SubscribeEvent annotation present, and only accept a single parameter, which has to be a instance of Event . Example public class Test { public static void main ( String [] args ) throws LoginException { JDABuilder . createDefault ( TOKEN ) . setEventManager ( new AnnotatedEventManager ()) . addEventListeners ( new Test ()) . build (); } @SubscribeEvent public void ohHeyAMessage ( MessageReceivedEvent event ) { System . out . println ( event . getMessage (). getContentDisplay ()); } } Don't forget actually registering this listener","title":"Using the Annotated System"},{"location":"introduction/faq/","text":"Frequently Asked Questions \u00b6 Didn't find an answer? Try asking in our Discord server What is a Guild? In Discord API terminology a \"Guild\" is often used to refer to Discord servers with channels/roles/users How do I make a bot account and add it to my server? Create an application at: https://discord.com/developers/applications/me Create a bot account for that application Get the client id of your application Replace CLIENT_ID in this link: https://discord.com/api/oauth2/authorize?scope=bot&client_id=CLIENT_ID Open the link, select your server and authorize the bot How do I connect my bot? Before you can connect you need to create a bot account Get the token of your bot Create your main class in an already setup project with JDA Supply the token to your JDABuilder instance and build! public static void main ( String [] args ) throws Exception { JDABuilder . createDefault ( THE_TOKEN ). build (); } Does this work with Kotlin? Yes! This library makes use of the JSR-305 annotations to be as compatible as possible with Kotlin. To be more idiomatic, you can use extensions like JDA-KTX and JDA-reactor . Why does method XXX not do anything? / What are RestActions? When you use one of JDA's methods that interacts with Discord (like sending a message or retrieving data) and the method seems to have no effect (and no errors), chances are that you didn't use a RestAction properly or not at all. You can read about what a RestAction is and how to use it in the appropriate Wiki entry . What is sharding? When a bot reaches 2500 joined guilds, Discord will refuse to start a connection with it. In order to connect bots of a size like that it has to shard the load. It is recommended to have 1000 guilds per shard. More information can be found in our README . How can I change the Playing... ? This is called a Presence and can be modified either before building JDA or at runtime. When building you can do JDABuilder.setActivity(Activity.playing(\"Thrones\")) and later change it using JDA.getPresence().setActivity(...) . In addition you may change the online status using setStatus(OnlineStatus.INVISIBLE) at the aforementioned locations. This may only be updated 5 times every 20 seconds and all other updates will be silently dropped by Discord. What is an Custom Emoji and Unicode Emoji? While there are a lot of standardized emojis (defined through Unicode spec), Discord allows Guilds to add their own emojis to be available. Those custom emojis are not just a plain Unicode character, but rather their own entity with id, name, ... To make this distinction more clear, we refer to the standard (Unicode) emojis as UnicodeEmoji and the Discord entities as CustomEmoji in JDA. You can create instances of this for use in various methods, such as reactions, using the factory methods of the Emoji interface. For instance, to create a unicode emoji instance, you use Emoji.fromUnicode(\"...\") with the string of unicode characters . To get the Unicode char(s) of some Emoji, you can either use a 3rd party library (such as emoji-java ) or just look them up online. You can add reactions with 3 different formats: // custom message . addReaction ( Emoji . fromFormatted ( \"<:minn:245267426227388416>\" )). queue (); // unicode escape message . addReaction ( Emoji . fromUnicode ( \"\\uD83D\\uDE02\" )). queue (); // codepoint notation message . addReaction ( Emoji . fromUnicode ( \"U+1F602\" )). queue (); Custom Emoji ( <:name:id> ) Unicode escape as UTF-16 characters ( \\uXXXX\\uXXXX ) Codepoint Notation as UTF-32 characters ( U+XXXXXXXXU+XXXXXXXX ) Why is there a warning from SLF4J when starting up? As of JDA 3.3.1, we use SLF4J for message logging. This means that you have to manually add any suitable SLF4J implementation library to your project. If your project does not have a SLF4J implementation library, following warning will be shown on startup: SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\". SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details. We currently provide a fallback implementation to not lose logging completely in this case. This fallback does not allow for a lot of configuration and we suggest using a proper implementation instead. I recommend Logback . You can just add it to your Gradle/Maven file as extra dependency. There is a basic setup guide in our wiki available here: Logging Setup What is the best way to delete messages from history? You can use MessageChannel.getIterableHistory to get an instance of MessagePaginationAction which can be used to load messages in various ways such as takeAsync(amount) or takeUntilAsync(condition) . This can be combined with MessageChannel.purgeMessages to bulk delete them from the channel. Keep in mind that purgeMessages will not delete all messages at once. Examples // Delete a number of messages void deleteMessages ( MessageChannel channel , int amount ) { channel . getIterableHistory () . takeAsync ( amount ) // CompletableFuture<List<Message>> . thenAccept ( channel :: purgeMessages ); // bulk deletes the messages from the channel (if possible) } // Delete messages up to the specified time void deleteUntil ( MessageChannel channel , OffsetDateTime time ) { channel . getIterableHistory () . takeUntilAsync ( message -> message . getTimeCreated (). isBefore ( time )) // Collect messages until they pass the time condition . thenAccept ( channel :: purgeMessages ); // bulk deletes the messages from the channel (if possible) } // Delete a number of messages for a specific author (this can be abstracted to any condition) void deleteFromUser ( MessageChannel channel , User author , int amount ) { List < Message > messages = new ArrayList <> (); // First create a list for your messages channel . getIterableHistory () . forEachAsync ( m -> { // Loop over the history and filter messages if ( m . getAuthor (). equals ( author )) messages . add ( m ); // Add these messages to a list (your collector) return messages . size () < amount ; // keep going until limit is reached (might be smart to also have a time condition here) }) // This is also a CompletableFuture<Void> so you can chain a callback . thenRun (() -> channel . purgeMessages ( messages )); // Run after loop is over, delete the messages in your list } How can I send a message to a specific channel without an event? Since you decided that you want to send a message to a specific channel you should already have either an ID or the NAME and optionally GUILD (ID/NAME) to locate this channel. Now all you need is access to the JDA instance of your bot session. This can easily be accomplished by passing the JDA instance as a parameter to the constructor of your class. With the JDA instance you can easily acquire the specific channel through your means. One example is the getTextChannelById(id) method and the other is the getTextChannelsByName(name, true) method . Note that names might not be unique to one channel (example \"general\") so the getTextChannelsByName(...) method returns a List<TextChannel> containing all matches for that specific name. If you desire a specific guild you can filter by first getting the guild via either getGuildById(guildId) or getGuildsByName(guildName, true) and calling the same methods on the guilds rather than the JDA instance. It is not recommended to keep a reference to a Guild stored for long as the JDA cache might stop updating the specific instance in favor of a new one later on (for example when reconnecting). Example - Handling the JDA instance public class EventChannel { private final JDA api ; public EventChannel ( JDA api ) { this . api = api ; } public void start () { ... } } Once you have this structure you have two choices of passing the JDA instance: Ready Event (recommended) Awaiting Ready public static void main ( String [] args ) { JDABuilder . createDefault ( TOKEN ) . addEventListeners ( listener ) // some other listeners/settings . addEventListeners ( new ListenerAdapter () { @Override public void onReady ( ReadyEvent event ) { new EventChannel ( event . getJDA ()). start (); // starts your channel with the ready event } }). build (); } public static void main ( String [] args ) { JDA api = JDABuilder . createDefault ( TOKEN ) . addEventListeners ( listener ) // some other listeners/settings . build (); new EventChannel ( api . awaitReady ()). start (); } How can I wait for a user response? Since JDA is event based you can implement a finite state machine . See my stackoverflow answers: - How to make a Discord Bot wait for a specific user to send a message with JDA? - Repetitive Consumer For Loop How can I find out which RestAction causes an ErrorResponseException? RestAction . setPassContext ( true ); // enable context by default RestAction . DEFAULT_FAILURE = Throwable :: printStackTrace ; Doing this will result in performance loss so it is recommended to only go to this extreme when you need to debug errors. To handle failures of a specific action, read this RestAction queue returned failure . How do I test other builds? You can use JitPack to provide other branches of JDA as a dependency. We have a tutorial on how to use it on this wiki page . How can I reduce the jar size of my bot? To reduce the jar size of your bot you can either use Maven or Gradle. Alternatively use the minimized jar from the download server with the name JDA-%VERSION%-withDependencies-min.jar Gradle Maven Exclude OPUS natives if you don't need encoding/decoding of audio (With LavaPlayer you don't need these natives) implementation ( \"net.dv8tion:JDA:$VERSION\" ) { exclude module: \"opus-java\" } For Kotlin DSL use exclude(module=\"opus-java\") Minimize your Jar with the Shadow Plugin shadowJar { minimize () } Exclude OPUS natives if you don't need encoding/decoding of audio (With LavaPlayer you don't need these natives) <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> $VERSION </version> <exclusions> <exclusion> <groupId> club.minnced </groupId> <artifactId> opus-java </artifactId> </exclusion> </exclusions> </dependency> Minimize your Jar using the shade plugin <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.1 </version> <configuration> <minimizeJar> true </minimizeJar> </configuration> <executions> <execution> <phase> package </phase> <goals> <goal> shade </goal> </goals> </execution> </executions> </plugin> How can I reduce the memory footprint of my bot? The default behavior of JDA is to cache everything except for messages. However, the library user can choose to disable some parts of the cache to decrease the memory impact of the bot process in exchange for less context and possibly more garbage accumulation. As of JDA 4.2.0 we use 3 factory methods to build JDA instances. createDefault - Enables cache for users who are active in voice channels and all cache flags createLight - Disables all user cache and cache flags create - Enables member chunking, caches all users, and enables all cache flags You can do more configuration manually though: Disable cache flags with JDABuilder#disableCache(CacheFlag...) This will disable certain cached entities such as the presences (activities) of users or channel permission overrides for members. Enable lazy loading with JDABuilder#setChunkingFilter(ChunkingFilter.NONE) This will only load members who actively participate in servers and not wait for users to load on startup. Disable Gateway Intents JDABuilder#disabledIntents(EnumSet) This will disable unused events from being received such as GUILD_MESSAGES_TYPING or similar. Disable Member Cache JDABuilder#setMemberCachePolicy(MemberCachePolicy) This will be used by JDA to decide whether to cache a member/user. You can use NONE to cache no users. Change the threading configuration with the pool setters: JDABuilder#setCallbackPool(ExecutorService) JDABuilder#setGatewayPool(ScheduledExecutorService) JDABuilder#setRateLimitPool(ScheduledExecutorService) How do I make a thread dump? The JDK provides a utility for creating a thread dump of a running JVM process: jstack -l <pid> (that's an L for \"Long\") Example: jstack -l 1337 > dump.txt This will list the thread dump and write it to a file called dump.txt . You can also create a thread dump directly in IntelliJ: This will copy the thread dump to your clipboard and you can save it to a text file.","title":"FAQ"},{"location":"introduction/faq/#frequently-asked-questions","text":"Didn't find an answer? Try asking in our Discord server What is a Guild? In Discord API terminology a \"Guild\" is often used to refer to Discord servers with channels/roles/users How do I make a bot account and add it to my server? Create an application at: https://discord.com/developers/applications/me Create a bot account for that application Get the client id of your application Replace CLIENT_ID in this link: https://discord.com/api/oauth2/authorize?scope=bot&client_id=CLIENT_ID Open the link, select your server and authorize the bot How do I connect my bot? Before you can connect you need to create a bot account Get the token of your bot Create your main class in an already setup project with JDA Supply the token to your JDABuilder instance and build! public static void main ( String [] args ) throws Exception { JDABuilder . createDefault ( THE_TOKEN ). build (); } Does this work with Kotlin? Yes! This library makes use of the JSR-305 annotations to be as compatible as possible with Kotlin. To be more idiomatic, you can use extensions like JDA-KTX and JDA-reactor . Why does method XXX not do anything? / What are RestActions? When you use one of JDA's methods that interacts with Discord (like sending a message or retrieving data) and the method seems to have no effect (and no errors), chances are that you didn't use a RestAction properly or not at all. You can read about what a RestAction is and how to use it in the appropriate Wiki entry . What is sharding? When a bot reaches 2500 joined guilds, Discord will refuse to start a connection with it. In order to connect bots of a size like that it has to shard the load. It is recommended to have 1000 guilds per shard. More information can be found in our README . How can I change the Playing... ? This is called a Presence and can be modified either before building JDA or at runtime. When building you can do JDABuilder.setActivity(Activity.playing(\"Thrones\")) and later change it using JDA.getPresence().setActivity(...) . In addition you may change the online status using setStatus(OnlineStatus.INVISIBLE) at the aforementioned locations. This may only be updated 5 times every 20 seconds and all other updates will be silently dropped by Discord. What is an Custom Emoji and Unicode Emoji? While there are a lot of standardized emojis (defined through Unicode spec), Discord allows Guilds to add their own emojis to be available. Those custom emojis are not just a plain Unicode character, but rather their own entity with id, name, ... To make this distinction more clear, we refer to the standard (Unicode) emojis as UnicodeEmoji and the Discord entities as CustomEmoji in JDA. You can create instances of this for use in various methods, such as reactions, using the factory methods of the Emoji interface. For instance, to create a unicode emoji instance, you use Emoji.fromUnicode(\"...\") with the string of unicode characters . To get the Unicode char(s) of some Emoji, you can either use a 3rd party library (such as emoji-java ) or just look them up online. You can add reactions with 3 different formats: // custom message . addReaction ( Emoji . fromFormatted ( \"<:minn:245267426227388416>\" )). queue (); // unicode escape message . addReaction ( Emoji . fromUnicode ( \"\\uD83D\\uDE02\" )). queue (); // codepoint notation message . addReaction ( Emoji . fromUnicode ( \"U+1F602\" )). queue (); Custom Emoji ( <:name:id> ) Unicode escape as UTF-16 characters ( \\uXXXX\\uXXXX ) Codepoint Notation as UTF-32 characters ( U+XXXXXXXXU+XXXXXXXX ) Why is there a warning from SLF4J when starting up? As of JDA 3.3.1, we use SLF4J for message logging. This means that you have to manually add any suitable SLF4J implementation library to your project. If your project does not have a SLF4J implementation library, following warning will be shown on startup: SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\". SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details. We currently provide a fallback implementation to not lose logging completely in this case. This fallback does not allow for a lot of configuration and we suggest using a proper implementation instead. I recommend Logback . You can just add it to your Gradle/Maven file as extra dependency. There is a basic setup guide in our wiki available here: Logging Setup What is the best way to delete messages from history? You can use MessageChannel.getIterableHistory to get an instance of MessagePaginationAction which can be used to load messages in various ways such as takeAsync(amount) or takeUntilAsync(condition) . This can be combined with MessageChannel.purgeMessages to bulk delete them from the channel. Keep in mind that purgeMessages will not delete all messages at once. Examples // Delete a number of messages void deleteMessages ( MessageChannel channel , int amount ) { channel . getIterableHistory () . takeAsync ( amount ) // CompletableFuture<List<Message>> . thenAccept ( channel :: purgeMessages ); // bulk deletes the messages from the channel (if possible) } // Delete messages up to the specified time void deleteUntil ( MessageChannel channel , OffsetDateTime time ) { channel . getIterableHistory () . takeUntilAsync ( message -> message . getTimeCreated (). isBefore ( time )) // Collect messages until they pass the time condition . thenAccept ( channel :: purgeMessages ); // bulk deletes the messages from the channel (if possible) } // Delete a number of messages for a specific author (this can be abstracted to any condition) void deleteFromUser ( MessageChannel channel , User author , int amount ) { List < Message > messages = new ArrayList <> (); // First create a list for your messages channel . getIterableHistory () . forEachAsync ( m -> { // Loop over the history and filter messages if ( m . getAuthor (). equals ( author )) messages . add ( m ); // Add these messages to a list (your collector) return messages . size () < amount ; // keep going until limit is reached (might be smart to also have a time condition here) }) // This is also a CompletableFuture<Void> so you can chain a callback . thenRun (() -> channel . purgeMessages ( messages )); // Run after loop is over, delete the messages in your list } How can I send a message to a specific channel without an event? Since you decided that you want to send a message to a specific channel you should already have either an ID or the NAME and optionally GUILD (ID/NAME) to locate this channel. Now all you need is access to the JDA instance of your bot session. This can easily be accomplished by passing the JDA instance as a parameter to the constructor of your class. With the JDA instance you can easily acquire the specific channel through your means. One example is the getTextChannelById(id) method and the other is the getTextChannelsByName(name, true) method . Note that names might not be unique to one channel (example \"general\") so the getTextChannelsByName(...) method returns a List<TextChannel> containing all matches for that specific name. If you desire a specific guild you can filter by first getting the guild via either getGuildById(guildId) or getGuildsByName(guildName, true) and calling the same methods on the guilds rather than the JDA instance. It is not recommended to keep a reference to a Guild stored for long as the JDA cache might stop updating the specific instance in favor of a new one later on (for example when reconnecting). Example - Handling the JDA instance public class EventChannel { private final JDA api ; public EventChannel ( JDA api ) { this . api = api ; } public void start () { ... } } Once you have this structure you have two choices of passing the JDA instance: Ready Event (recommended) Awaiting Ready public static void main ( String [] args ) { JDABuilder . createDefault ( TOKEN ) . addEventListeners ( listener ) // some other listeners/settings . addEventListeners ( new ListenerAdapter () { @Override public void onReady ( ReadyEvent event ) { new EventChannel ( event . getJDA ()). start (); // starts your channel with the ready event } }). build (); } public static void main ( String [] args ) { JDA api = JDABuilder . createDefault ( TOKEN ) . addEventListeners ( listener ) // some other listeners/settings . build (); new EventChannel ( api . awaitReady ()). start (); } How can I wait for a user response? Since JDA is event based you can implement a finite state machine . See my stackoverflow answers: - How to make a Discord Bot wait for a specific user to send a message with JDA? - Repetitive Consumer For Loop How can I find out which RestAction causes an ErrorResponseException? RestAction . setPassContext ( true ); // enable context by default RestAction . DEFAULT_FAILURE = Throwable :: printStackTrace ; Doing this will result in performance loss so it is recommended to only go to this extreme when you need to debug errors. To handle failures of a specific action, read this RestAction queue returned failure . How do I test other builds? You can use JitPack to provide other branches of JDA as a dependency. We have a tutorial on how to use it on this wiki page . How can I reduce the jar size of my bot? To reduce the jar size of your bot you can either use Maven or Gradle. Alternatively use the minimized jar from the download server with the name JDA-%VERSION%-withDependencies-min.jar Gradle Maven Exclude OPUS natives if you don't need encoding/decoding of audio (With LavaPlayer you don't need these natives) implementation ( \"net.dv8tion:JDA:$VERSION\" ) { exclude module: \"opus-java\" } For Kotlin DSL use exclude(module=\"opus-java\") Minimize your Jar with the Shadow Plugin shadowJar { minimize () } Exclude OPUS natives if you don't need encoding/decoding of audio (With LavaPlayer you don't need these natives) <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> $VERSION </version> <exclusions> <exclusion> <groupId> club.minnced </groupId> <artifactId> opus-java </artifactId> </exclusion> </exclusions> </dependency> Minimize your Jar using the shade plugin <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.1 </version> <configuration> <minimizeJar> true </minimizeJar> </configuration> <executions> <execution> <phase> package </phase> <goals> <goal> shade </goal> </goals> </execution> </executions> </plugin> How can I reduce the memory footprint of my bot? The default behavior of JDA is to cache everything except for messages. However, the library user can choose to disable some parts of the cache to decrease the memory impact of the bot process in exchange for less context and possibly more garbage accumulation. As of JDA 4.2.0 we use 3 factory methods to build JDA instances. createDefault - Enables cache for users who are active in voice channels and all cache flags createLight - Disables all user cache and cache flags create - Enables member chunking, caches all users, and enables all cache flags You can do more configuration manually though: Disable cache flags with JDABuilder#disableCache(CacheFlag...) This will disable certain cached entities such as the presences (activities) of users or channel permission overrides for members. Enable lazy loading with JDABuilder#setChunkingFilter(ChunkingFilter.NONE) This will only load members who actively participate in servers and not wait for users to load on startup. Disable Gateway Intents JDABuilder#disabledIntents(EnumSet) This will disable unused events from being received such as GUILD_MESSAGES_TYPING or similar. Disable Member Cache JDABuilder#setMemberCachePolicy(MemberCachePolicy) This will be used by JDA to decide whether to cache a member/user. You can use NONE to cache no users. Change the threading configuration with the pool setters: JDABuilder#setCallbackPool(ExecutorService) JDABuilder#setGatewayPool(ScheduledExecutorService) JDABuilder#setRateLimitPool(ScheduledExecutorService) How do I make a thread dump? The JDK provides a utility for creating a thread dump of a running JVM process: jstack -l <pid> (that's an L for \"Long\") Example: jstack -l 1337 > dump.txt This will list the thread dump and write it to a file called dump.txt . You can also create a thread dump directly in IntelliJ: This will copy the thread dump to your clipboard and you can save it to a text file.","title":"Frequently Asked Questions"},{"location":"introduction/jda/","text":"JDA (Java Discord API) \u00b6 JDA strives to provide a clean and full wrapping of the Discord REST API and its Websocket-Events for Java. If you have any suggestions/questions/feedback for this wiki, please visit the #wiki-dev channel in the JDA Discord Server Examples public class ReadyListener implements EventListener { public static void main ( String [] args ) throws InterruptedException { // Note: It is important to register your ReadyListener before building JDA jda = JDABuilder . createDefault ( \"token\" ) . addEventListeners ( new ReadyListener ()) . build (); // optionally block until JDA is ready jda . awaitReady (); } @Override public void onEvent ( GenericEvent event ) { if ( event instanceof ReadyEvent ) System . out . println ( \"API is ready!\" ); } } public class MessageListener extends ListenerAdapter { public static void main ( String [] args ) { JDA jda = JDABuilder . createDefault ( \"token\" ) . enableIntents ( GatewayIntent . MESSAGE_CONTENT ) // enables explicit access to message.getContentDisplay() . build (); //You can also add event listeners to the already built JDA instance // Note that some events may not be received if the listener is added after calling build() // This includes events such as the ReadyEvent jda . addEventListener ( new MessageListener ()); } @Override public void onMessageReceived ( MessageReceivedEvent event ) { if ( event . isFromType ( ChannelType . PRIVATE )) { System . out . printf ( \"[PM] %s: %s\\n\" , event . getAuthor (). getName (), event . getMessage (). getContentDisplay ()); } else { System . out . printf ( \"[%s][%s] %s: %s\\n\" , event . getGuild (). getName (), event . getTextChannel (). getName (), event . getMember (). getEffectiveName (), event . getMessage (). getContentDisplay ()); } } } More Examples : We provide a small set of Examples in the Example Directory . Download \u00b6 You can get the latest released builds here: Promoted Downloads If you want the most up-to-date builds, you can get them here: Latest Build Downloads Docs \u00b6 Javadocs are available in both jar format and web format. The jar format is available on the Promoted Downloads page or on any of the build pages of the legacy v4 Downloads or v5 Downloads . The web format allows for viewing of the Latest Docs or legacy Docs and also viewing of each individual build's javadoc. To view the javadoc for a specific build, you will need to go to that build's page on the build server and download the javadoc jar for the specific build. A shortcut would be: https://ci.dv8tion.net/job/JDA5/BUILD_NUMBER_GOES_HERE , you just need to replace the \"BUILD_NUMBER_GOES_HERE\" with the build you want. Once you have the jar extract the files with the zip tool of your preference (winrar or 7zip, etc.) and open the index.html file with your internet browser. Getting Help \u00b6 If you need help, or just want to talk with the JDA or other Devs, you can join the Official JDA Discord Guild . Alternatively you can also join the Unofficial Discord API Guild . Once you joined, you can find JDA-specific help in the #java_jda channel. The JDA specific server will often have faster responses than the #java_jda channel in the Discord API server. For guides and setup help you can also take a look at this wiki. Especially interesting are the Getting Started Pages. Contributing to JDA \u00b6 If you want to contribute to JDA, make sure to base your branch off of our master branch (or a feature-branch) and create your PR into that same branch. We will be rejecting any PRs between branches or into release branches! It is also highly recommended to get in touch with the Devs before opening Pull Requests (either through an issue or the Discord servers mentioned above). It is very possible that your change might already be in development or you missed something. More information can be found at the wiki page Contributing Dependencies \u00b6 This project requires Java 8 . For other dependencies, see README","title":"JDA"},{"location":"introduction/jda/#jda-java-discord-api","text":"JDA strives to provide a clean and full wrapping of the Discord REST API and its Websocket-Events for Java. If you have any suggestions/questions/feedback for this wiki, please visit the #wiki-dev channel in the JDA Discord Server Examples public class ReadyListener implements EventListener { public static void main ( String [] args ) throws InterruptedException { // Note: It is important to register your ReadyListener before building JDA jda = JDABuilder . createDefault ( \"token\" ) . addEventListeners ( new ReadyListener ()) . build (); // optionally block until JDA is ready jda . awaitReady (); } @Override public void onEvent ( GenericEvent event ) { if ( event instanceof ReadyEvent ) System . out . println ( \"API is ready!\" ); } } public class MessageListener extends ListenerAdapter { public static void main ( String [] args ) { JDA jda = JDABuilder . createDefault ( \"token\" ) . enableIntents ( GatewayIntent . MESSAGE_CONTENT ) // enables explicit access to message.getContentDisplay() . build (); //You can also add event listeners to the already built JDA instance // Note that some events may not be received if the listener is added after calling build() // This includes events such as the ReadyEvent jda . addEventListener ( new MessageListener ()); } @Override public void onMessageReceived ( MessageReceivedEvent event ) { if ( event . isFromType ( ChannelType . PRIVATE )) { System . out . printf ( \"[PM] %s: %s\\n\" , event . getAuthor (). getName (), event . getMessage (). getContentDisplay ()); } else { System . out . printf ( \"[%s][%s] %s: %s\\n\" , event . getGuild (). getName (), event . getTextChannel (). getName (), event . getMember (). getEffectiveName (), event . getMessage (). getContentDisplay ()); } } } More Examples : We provide a small set of Examples in the Example Directory .","title":"JDA (Java Discord API)"},{"location":"introduction/jda/#download","text":"You can get the latest released builds here: Promoted Downloads If you want the most up-to-date builds, you can get them here: Latest Build Downloads","title":"Download"},{"location":"introduction/jda/#docs","text":"Javadocs are available in both jar format and web format. The jar format is available on the Promoted Downloads page or on any of the build pages of the legacy v4 Downloads or v5 Downloads . The web format allows for viewing of the Latest Docs or legacy Docs and also viewing of each individual build's javadoc. To view the javadoc for a specific build, you will need to go to that build's page on the build server and download the javadoc jar for the specific build. A shortcut would be: https://ci.dv8tion.net/job/JDA5/BUILD_NUMBER_GOES_HERE , you just need to replace the \"BUILD_NUMBER_GOES_HERE\" with the build you want. Once you have the jar extract the files with the zip tool of your preference (winrar or 7zip, etc.) and open the index.html file with your internet browser.","title":"Docs"},{"location":"introduction/jda/#getting-help","text":"If you need help, or just want to talk with the JDA or other Devs, you can join the Official JDA Discord Guild . Alternatively you can also join the Unofficial Discord API Guild . Once you joined, you can find JDA-specific help in the #java_jda channel. The JDA specific server will often have faster responses than the #java_jda channel in the Discord API server. For guides and setup help you can also take a look at this wiki. Especially interesting are the Getting Started Pages.","title":"Getting Help"},{"location":"introduction/jda/#contributing-to-jda","text":"If you want to contribute to JDA, make sure to base your branch off of our master branch (or a feature-branch) and create your PR into that same branch. We will be rejecting any PRs between branches or into release branches! It is also highly recommended to get in touch with the Devs before opening Pull Requests (either through an issue or the Discord servers mentioned above). It is very possible that your change might already be in development or you missed something. More information can be found at the wiki page Contributing","title":"Contributing to JDA"},{"location":"introduction/jda/#dependencies","text":"This project requires Java 8 . For other dependencies, see README","title":"Dependencies"},{"location":"introduction/migration-v3-v4/","text":"Migration Guide 3.X to 4.X \u00b6 This version includes a number of breaking changes. Extensions That Support 4.X \u00b6 Here is a list of known extensions that support 4.X. The ones that are not checked do not support it yet. You should check that everything used in your project supports 4.X before starting migration. jda-reactor LavaPlayer jda-nas (since 1.1.0 ) JDA-Utilities (since 3.0.1 ) Lavalink Client (since 4.0 ) JDAction (see #6 ) Package layout changes \u00b6 Since we removed the client-only features from JDA the package didn't make much sense anymore. Instead we have merged core , bot , and client into api . The new package prefix for the API functionality is now net.dv8tion.jda.api . If you used internal classes they will not be available under this prefix but instead use net.dv8tion.jda.internal . Something like net.dv8tion.jda.core.entities.impl has been moved to net.dv8tion.jda.internal.entities since the internal packages only contain implementations anyway. In the case that PermissionUtil.checkPermissions was used in your code, this should be changed to member.hasPermission(...) or role.hasPermission(...) . Removed Features \u00b6 Almost everything from net.dv8tion.jda.client has been removed as its not supported by the API and can lead to account termination which we don't want to happen. Additionally, most of the features advertised by the interfaces in client were not even implemented or documented properly. Everything on JDABot has been moved into JDA . The flag to disable the audio system with setAudioEnabled(false) has been removed. This flag only enabled an exception for Guild.getAudioManager() which is unnecessary. The entire net.dv8tion.jda.webhook package has been moved to a dedicated library at https://github.com/MinnDevelopment/discord-webhooks The methods buildBlocking and buildAsync have been removed as they were already deprecated. To replace buildBlocking you should use awaitReady() on the JDA instance returned by build() . The overloads for sendFile that accepted a Message as their last parameter have been removed in favor of MessageAction.addFile . For example sendFile(file, message) becomes sendMessage(message).addFile(file) . Both getWebSocketTrace and getCloudflareRays have been removed without replacements. These are not officially supported by the Discord API and subject to change. Renamed Classes \u00b6 Some classes have been renamed to better represent their meaning. Channel -> GuildChannel Game -> Activity (also CacheFlag.GAME -> CacheFlag.ACTIVITY ) GuildMemberNickChangeEvent -> GuildMemberUpdateNicknameEvent Renamed Methods \u00b6 A few methods were renamed for better consistency and clarity. JDABuilder.addEventListener -> JDABuilder.addEventListeners JDABuilder.setGame -> JDABuilder.setActivity (same for Presence and DefaultShardManagerBuilder ) Invite.getURL -> Invite.getUrl JDA.getPing -> JDA.getGatewayPing JDA.getWebhookById -> JDA.retrieveWebhookById Guild.getWebhooks -> Guild.retrieveWebhooks (same for TextChannel ) Guild.getInvites -> Guild.retrieveInvites (same for GuildChannel ) Guild.getAuditLogs -> Guild.retrieveAuditLogs Guild.getBan[ById|List] -> Guild.retrieveBan[ById|List] Guild.getVanityUrl -> Guild.retrieveVanityUrl MessageChannel.getMessageById -> MessageChannel.retrieveMessageById JDA.getApplicationInfo -> JDA.retrieveApplicationInfo AudioManager.getReceiveHandler -> AudioManager.getReceivingHandler GuildController.addSingleRoleToMember -> Guild.addRoleToMember (same for removeSingleRoleFromMember ) GuildController.setNickname -> Guild.modifyNickname GuildMemberNickChangeEvent.getPrevNick -> GuildMemberUpdateNicknameEvent.getOldNickname GuildMemberNickChangeEvent.getNewNick -> GuildMemberUpdateNicknameEvent.getNewNickname ISnowflake.getCreationTime -> ISnowflake.getTimeCreated Changed Functionality \u00b6 Some methods have changed their signature in a breaking way. This is supposed to improve either internal code or make the interface more versatile. JDABuilder and DefaultShardManagerBuilder \u00b6 As of 4.2.0 the JDABuilder constructor has been deprecated in favor of 3 factory methods: createDefault createLight create Further details are explained in a dedicated wiki page here: Gateway Intents and Member Cache Policy Permission Lists \u00b6 Everything that once returned List<Permission> has been changed to return EnumSet<Permission> instead for a better representation. Message Attachments \u00b6 You can no longer use blocking operations to download attachments of a message. Instead we replaced the old download() with downloadToFile() and similar methods. These use CompletableFuture to provide continuations such as thenAccept and whenComplete . Examples are provided in the documentation for the respective methods. Audio System \u00b6 AudioSendHandler.provide20MsAudio() now returns ByteBuffer instead of byte[] . An easy transition is to use ByteBuffer.wrap(byte[]) . This was done to allow re-using the same buffer for multiple packets instead of allocating a fitting array every time. PermissionOverride \u00b6 PermissionOverride.getManager() now returns a PermissionOverrideAction instead to remove code duplication. You can now also use GuildChannel.upsertPermissionOverride which will either return getManager() on an existing override or use putPermissionOverride() if there is no existing override. Events \u00b6 IEventManager.handle , EventListener.onEvent , and ListenerAdapter.onGenericEvent now accepts GenericEvent which is a new interface that allows a more versatile hierarchy for the events it can handle. UpdateEvent is now a subinterface for GenericEvent . GuildController \u00b6 The methods provided by the old GuildController class have been moved into the Guild interface. The GuildController has been removed completely. Additionally, Member received a few new shortcuts like Member.ban(int) . The methods addRolesToMember and removeRolesFromMember have been removed and should be replaced with modifyMemberRoles . Messages \u00b6 Since we added @Nonnull and @Nullable annotations we had to compromise on conditional nullability. This means the methods like Message.getTextChannel now throw instead of returning null if the message was not sent in a TextChannel . You can use Message.isFromType to test for the channel type. Compression \u00b6 To support other compression algorithms like zstd that Discord may offer in the future we changed setCompressionEnabled to setCompression . In this change we also replaced the boolean with a new enum for each algorithm. The new way to disable compression is setCompression(Compression.NONE) . RestAction \u00b6 All RestAction types have been changed to be interfaces to improve maintainability. Additionally, submitAfter now returns DelayedCompletableFuture to allow usage of continuations.","title":"Migration V3 -> V4"},{"location":"introduction/migration-v3-v4/#migration-guide-3x-to-4x","text":"This version includes a number of breaking changes.","title":"Migration Guide 3.X to 4.X"},{"location":"introduction/migration-v3-v4/#extensions-that-support-4x","text":"Here is a list of known extensions that support 4.X. The ones that are not checked do not support it yet. You should check that everything used in your project supports 4.X before starting migration. jda-reactor LavaPlayer jda-nas (since 1.1.0 ) JDA-Utilities (since 3.0.1 ) Lavalink Client (since 4.0 ) JDAction (see #6 )","title":"Extensions That Support 4.X"},{"location":"introduction/migration-v3-v4/#package-layout-changes","text":"Since we removed the client-only features from JDA the package didn't make much sense anymore. Instead we have merged core , bot , and client into api . The new package prefix for the API functionality is now net.dv8tion.jda.api . If you used internal classes they will not be available under this prefix but instead use net.dv8tion.jda.internal . Something like net.dv8tion.jda.core.entities.impl has been moved to net.dv8tion.jda.internal.entities since the internal packages only contain implementations anyway. In the case that PermissionUtil.checkPermissions was used in your code, this should be changed to member.hasPermission(...) or role.hasPermission(...) .","title":"Package layout changes"},{"location":"introduction/migration-v3-v4/#removed-features","text":"Almost everything from net.dv8tion.jda.client has been removed as its not supported by the API and can lead to account termination which we don't want to happen. Additionally, most of the features advertised by the interfaces in client were not even implemented or documented properly. Everything on JDABot has been moved into JDA . The flag to disable the audio system with setAudioEnabled(false) has been removed. This flag only enabled an exception for Guild.getAudioManager() which is unnecessary. The entire net.dv8tion.jda.webhook package has been moved to a dedicated library at https://github.com/MinnDevelopment/discord-webhooks The methods buildBlocking and buildAsync have been removed as they were already deprecated. To replace buildBlocking you should use awaitReady() on the JDA instance returned by build() . The overloads for sendFile that accepted a Message as their last parameter have been removed in favor of MessageAction.addFile . For example sendFile(file, message) becomes sendMessage(message).addFile(file) . Both getWebSocketTrace and getCloudflareRays have been removed without replacements. These are not officially supported by the Discord API and subject to change.","title":"Removed Features"},{"location":"introduction/migration-v3-v4/#renamed-classes","text":"Some classes have been renamed to better represent their meaning. Channel -> GuildChannel Game -> Activity (also CacheFlag.GAME -> CacheFlag.ACTIVITY ) GuildMemberNickChangeEvent -> GuildMemberUpdateNicknameEvent","title":"Renamed Classes"},{"location":"introduction/migration-v3-v4/#renamed-methods","text":"A few methods were renamed for better consistency and clarity. JDABuilder.addEventListener -> JDABuilder.addEventListeners JDABuilder.setGame -> JDABuilder.setActivity (same for Presence and DefaultShardManagerBuilder ) Invite.getURL -> Invite.getUrl JDA.getPing -> JDA.getGatewayPing JDA.getWebhookById -> JDA.retrieveWebhookById Guild.getWebhooks -> Guild.retrieveWebhooks (same for TextChannel ) Guild.getInvites -> Guild.retrieveInvites (same for GuildChannel ) Guild.getAuditLogs -> Guild.retrieveAuditLogs Guild.getBan[ById|List] -> Guild.retrieveBan[ById|List] Guild.getVanityUrl -> Guild.retrieveVanityUrl MessageChannel.getMessageById -> MessageChannel.retrieveMessageById JDA.getApplicationInfo -> JDA.retrieveApplicationInfo AudioManager.getReceiveHandler -> AudioManager.getReceivingHandler GuildController.addSingleRoleToMember -> Guild.addRoleToMember (same for removeSingleRoleFromMember ) GuildController.setNickname -> Guild.modifyNickname GuildMemberNickChangeEvent.getPrevNick -> GuildMemberUpdateNicknameEvent.getOldNickname GuildMemberNickChangeEvent.getNewNick -> GuildMemberUpdateNicknameEvent.getNewNickname ISnowflake.getCreationTime -> ISnowflake.getTimeCreated","title":"Renamed Methods"},{"location":"introduction/migration-v3-v4/#changed-functionality","text":"Some methods have changed their signature in a breaking way. This is supposed to improve either internal code or make the interface more versatile.","title":"Changed Functionality"},{"location":"introduction/migration-v3-v4/#jdabuilder-and-defaultshardmanagerbuilder","text":"As of 4.2.0 the JDABuilder constructor has been deprecated in favor of 3 factory methods: createDefault createLight create Further details are explained in a dedicated wiki page here: Gateway Intents and Member Cache Policy","title":"JDABuilder and DefaultShardManagerBuilder"},{"location":"introduction/migration-v3-v4/#permission-lists","text":"Everything that once returned List<Permission> has been changed to return EnumSet<Permission> instead for a better representation.","title":"Permission Lists"},{"location":"introduction/migration-v3-v4/#message-attachments","text":"You can no longer use blocking operations to download attachments of a message. Instead we replaced the old download() with downloadToFile() and similar methods. These use CompletableFuture to provide continuations such as thenAccept and whenComplete . Examples are provided in the documentation for the respective methods.","title":"Message Attachments"},{"location":"introduction/migration-v3-v4/#audio-system","text":"AudioSendHandler.provide20MsAudio() now returns ByteBuffer instead of byte[] . An easy transition is to use ByteBuffer.wrap(byte[]) . This was done to allow re-using the same buffer for multiple packets instead of allocating a fitting array every time.","title":"Audio System"},{"location":"introduction/migration-v3-v4/#permissionoverride","text":"PermissionOverride.getManager() now returns a PermissionOverrideAction instead to remove code duplication. You can now also use GuildChannel.upsertPermissionOverride which will either return getManager() on an existing override or use putPermissionOverride() if there is no existing override.","title":"PermissionOverride"},{"location":"introduction/migration-v3-v4/#events","text":"IEventManager.handle , EventListener.onEvent , and ListenerAdapter.onGenericEvent now accepts GenericEvent which is a new interface that allows a more versatile hierarchy for the events it can handle. UpdateEvent is now a subinterface for GenericEvent .","title":"Events"},{"location":"introduction/migration-v3-v4/#guildcontroller","text":"The methods provided by the old GuildController class have been moved into the Guild interface. The GuildController has been removed completely. Additionally, Member received a few new shortcuts like Member.ban(int) . The methods addRolesToMember and removeRolesFromMember have been removed and should be replaced with modifyMemberRoles .","title":"GuildController"},{"location":"introduction/migration-v3-v4/#messages","text":"Since we added @Nonnull and @Nullable annotations we had to compromise on conditional nullability. This means the methods like Message.getTextChannel now throw instead of returning null if the message was not sent in a TextChannel . You can use Message.isFromType to test for the channel type.","title":"Messages"},{"location":"introduction/migration-v3-v4/#compression","text":"To support other compression algorithms like zstd that Discord may offer in the future we changed setCompressionEnabled to setCompression . In this change we also replaced the boolean with a new enum for each algorithm. The new way to disable compression is setCompression(Compression.NONE) .","title":"Compression"},{"location":"introduction/migration-v3-v4/#restaction","text":"All RestAction types have been changed to be interfaces to improve maintainability. Additionally, submitAfter now returns DelayedCompletableFuture to allow usage of continuations.","title":"RestAction"},{"location":"setup/eclipse/","text":"Eclipse Setup \u00b6 Gradle Setup Maven Setup Jar Setup If you have Eclipse IDE for Java Developers installed, skip to 2. , otherwise you need to install the Buildship Gradle Integration plugin first: Open up Eclipse and go to the Marketplace (located under the Help tab) Search for \"Gradle\" and install Buildship Gradle Integration ( Plugin-Page ) After the plugin is installed, relaunch Eclipse Right click within Package/Project Explorer and select New > Other... In the Gradle folder, select Gradle Project Type a name for your Project and click on Finish . Your setup should look like this at this point: Delete the classes within src/main/java and src/test/java Open up and edit the file build.gradle Replace its content with the following code: plugins { id ( \"java\" ) id ( \"application\" ) id ( \"com.github.johnrengelman.shadow\" ) version \"6.0.0\" } mainClassName = \"com.example.jda.Bot\" version '1.0' sourceCompatibility = 1.8 repositories { mavenCentral () } dependencies { implementation ( \"net.dv8tion:JDA:#.#.#_###\" ) } compileJava . options . encoding = \"UTF-8\" Adjust the version of JDA you want to use (see dependencies-section of file) and fill in your Main-Class as soon as you have one (the one containing your public static void main(String[] args) method) Save the file and do the following: Right click your project > Gradle > Refresh All Once all the dependencies have been downloaded, create your desired packages/classes in src/main/java and start coding! To build your project you can run gradlew shadowJar in a terminal of your project root, and it will produce a jar filled with your compiled code and JDA included in a single jar file! The jar can be found in build/libs Setup Logback Continue with Getting Started Prerequisites: Maven-Plugin and local Maven installation Create a new Maven project. (File -> New -> Other -> Maven -> Maven Project) Check the Create a simple project box on the next page as we don't need to worry about archetypes. Add a groupId, artifactId and a name. Make sure you try to follow the naming conventions while you are at this step. The result could look like the image below. Now let's start configuring it, first off, open up your pom.xml and add the following lines right after </description> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <project.reporting.outputEncoding> UTF-8 </project.reporting.outputEncoding> </properties> This will make your project support UTF-8 characters (So you can have it on Japanese servers for example) and also force Java 8, which is needed. Now, add the dependency, make sure you change X.Y.Z-beta.W to the latest version number (You can find it in the releases: https://github.com/DV8FromTheWorld/JDA/releases) <dependencies> <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> X.Y.Z-beta.W </version> </dependency> </dependencies> Now you need to set up the (build) maven-shade and maven-compile plugins, add the following lines right after </dependencies> Note The following changes will force the compiler to use Java 8 (JDA needs it), so make sure you have it installed. <build> <plugins> <plugin> <artifactId> maven-compiler-plugin </artifactId> <version> 3.8.1 </version> <configuration> <source> 1.8 </source> <target> 1.8 </target> </configuration> </plugin> <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.4 </version> <configuration> <transformers> <transformer implementation= \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" > <mainClass> YourMainClass </mainClass> <!-- (1) --> </transformer> </transformers> <createDependencyReducedPom> false </createDependencyReducedPom> </configuration> <executions> <execution> <phase> package </phase> <goals> <goal> shade </goal> </goals> </execution> </executions> </plugin> </plugins> </build> You have to replace this with a path to your main class like me.myname.mybotproject.Main After that, the project must be updated to download the dependencies. Right click > Maven > Update Project You are done! Now you can head to the Javadocs or see examples at the Examples page. Setup Logback Continue with Getting Started Download the latest (Binary) version of JDA (with Dependencies): (Recommended) https://github.com/DV8FromTheWorld/JDA/releases/ (Latest/Dev) https://ci.dv8tion.net/job/JDA5/ Create a new Java Project Fill out the bot name, and set it to Java 8 (or above if available). This option might be set automatically when the Use default location box is checked. Right click the project, go to Properties Click on Java Build Path , then click on Libraries , then on Classpath , Add External JARs... Add your downloaded JDA-withDependencies-x.x.x_xxx.jar and expand its properties If you don't want Javadoc and source annotations, skip to 11 (not recommended). Click on Source Attachment , then on Edit... , then mark External Locations and click on External File Here, add your JDA-x.x.x_xxx-sources.jar and click on OK Next, click on Javadoc Location , then on Edit... , then mark Javadoc in archive and click on Browse Here, add your JDA-x.y.z-www.p-javadoc.jar and click on OK Setup Logback Continue with Getting Started","title":"Eclipse Setup"},{"location":"setup/eclipse/#eclipse-setup","text":"Gradle Setup Maven Setup Jar Setup If you have Eclipse IDE for Java Developers installed, skip to 2. , otherwise you need to install the Buildship Gradle Integration plugin first: Open up Eclipse and go to the Marketplace (located under the Help tab) Search for \"Gradle\" and install Buildship Gradle Integration ( Plugin-Page ) After the plugin is installed, relaunch Eclipse Right click within Package/Project Explorer and select New > Other... In the Gradle folder, select Gradle Project Type a name for your Project and click on Finish . Your setup should look like this at this point: Delete the classes within src/main/java and src/test/java Open up and edit the file build.gradle Replace its content with the following code: plugins { id ( \"java\" ) id ( \"application\" ) id ( \"com.github.johnrengelman.shadow\" ) version \"6.0.0\" } mainClassName = \"com.example.jda.Bot\" version '1.0' sourceCompatibility = 1.8 repositories { mavenCentral () } dependencies { implementation ( \"net.dv8tion:JDA:#.#.#_###\" ) } compileJava . options . encoding = \"UTF-8\" Adjust the version of JDA you want to use (see dependencies-section of file) and fill in your Main-Class as soon as you have one (the one containing your public static void main(String[] args) method) Save the file and do the following: Right click your project > Gradle > Refresh All Once all the dependencies have been downloaded, create your desired packages/classes in src/main/java and start coding! To build your project you can run gradlew shadowJar in a terminal of your project root, and it will produce a jar filled with your compiled code and JDA included in a single jar file! The jar can be found in build/libs Setup Logback Continue with Getting Started Prerequisites: Maven-Plugin and local Maven installation Create a new Maven project. (File -> New -> Other -> Maven -> Maven Project) Check the Create a simple project box on the next page as we don't need to worry about archetypes. Add a groupId, artifactId and a name. Make sure you try to follow the naming conventions while you are at this step. The result could look like the image below. Now let's start configuring it, first off, open up your pom.xml and add the following lines right after </description> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <project.reporting.outputEncoding> UTF-8 </project.reporting.outputEncoding> </properties> This will make your project support UTF-8 characters (So you can have it on Japanese servers for example) and also force Java 8, which is needed. Now, add the dependency, make sure you change X.Y.Z-beta.W to the latest version number (You can find it in the releases: https://github.com/DV8FromTheWorld/JDA/releases) <dependencies> <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> X.Y.Z-beta.W </version> </dependency> </dependencies> Now you need to set up the (build) maven-shade and maven-compile plugins, add the following lines right after </dependencies> Note The following changes will force the compiler to use Java 8 (JDA needs it), so make sure you have it installed. <build> <plugins> <plugin> <artifactId> maven-compiler-plugin </artifactId> <version> 3.8.1 </version> <configuration> <source> 1.8 </source> <target> 1.8 </target> </configuration> </plugin> <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.2.4 </version> <configuration> <transformers> <transformer implementation= \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" > <mainClass> YourMainClass </mainClass> <!-- (1) --> </transformer> </transformers> <createDependencyReducedPom> false </createDependencyReducedPom> </configuration> <executions> <execution> <phase> package </phase> <goals> <goal> shade </goal> </goals> </execution> </executions> </plugin> </plugins> </build> You have to replace this with a path to your main class like me.myname.mybotproject.Main After that, the project must be updated to download the dependencies. Right click > Maven > Update Project You are done! Now you can head to the Javadocs or see examples at the Examples page. Setup Logback Continue with Getting Started Download the latest (Binary) version of JDA (with Dependencies): (Recommended) https://github.com/DV8FromTheWorld/JDA/releases/ (Latest/Dev) https://ci.dv8tion.net/job/JDA5/ Create a new Java Project Fill out the bot name, and set it to Java 8 (or above if available). This option might be set automatically when the Use default location box is checked. Right click the project, go to Properties Click on Java Build Path , then click on Libraries , then on Classpath , Add External JARs... Add your downloaded JDA-withDependencies-x.x.x_xxx.jar and expand its properties If you don't want Javadoc and source annotations, skip to 11 (not recommended). Click on Source Attachment , then on Edit... , then mark External Locations and click on External File Here, add your JDA-x.x.x_xxx-sources.jar and click on OK Next, click on Javadoc Location , then on Edit... , then mark Javadoc in archive and click on Browse Here, add your JDA-x.y.z-www.p-javadoc.jar and click on OK Setup Logback Continue with Getting Started","title":"Eclipse Setup"},{"location":"setup/intellij/","text":"IntelliJ IDEA Setup \u00b6 Newer versions of IntelliJ IDEA Older versions of IntelliJ IDEA Navigate to \"New Project\" from any view Select Gradle -> Java as the type of Project and make sure the correct JDK is selected (Java 8 or higher) Provide a title for your project and define your GroupId and optionally the ArtifactId and initial Version in the \"Artifact Coordinates\" subsection Optionally enable Auto-Importing of the Gradle file in the Gradle settings. This is also the place where you could switch the runner for your project (By default, Gradle is used to run your application and tests) Let IntelliJ index your project. Open build.gradle Populate the build file with the following plugins { id 'application' id 'com.github.johnrengelman.shadow' version '5.2.0' } mainClassName = 'com.example.jda.Bot' // (1) version '1.0' def jdaVersion = 'JDA_VERSION_HERE' // (2) sourceCompatibility = targetCompatibility = 1.8 repositories { mavenCentral () } dependencies { implementation ( \"net.dv8tion:JDA:$jdaVersion\" ) } compileJava . options . encoding = 'UTF-8' Replace the mainClassName value with the path to your main class later on! Replace the JDA_VERSION_HERE with the one mentioned in the latest release If IntelliJ IDEA didn't already do so automatically, set up a source folder as src/main/java Create your group package. Example: me.name.bot Make your main class. Example: Bot.java . Your directory tree should look like this: ProjectName -> src/main/java -> me/name/bot -> Bot.java -> gradle/wrapper -> gradle-wrapper.properties -> gradle/wrapper -> gradle-wrapper.jar -> build.gradle -> settings.gradle Configure the mainClassName value in the build.gradle to your class. Example: me.name.bot.Bot To build your finished project simply use the shadowJar task in your Gradle tool window on right hand side of your editor. This will build a jar in build/libs . The one with the -all suffix is the shadow jar. > You can also run your project with the run Gradle task! Setup Logback Continue with Getting Started Open the Project view Create a new Project Select Gradle > Java Configure your SDK to use Java 1.8 Click Next and fill in your groupId and your artifactId. Example: me.name and bot Check Use auto-import and click Next > Finish","title":"IntelliJ IDEA Setup"},{"location":"setup/intellij/#intellij-idea-setup","text":"Newer versions of IntelliJ IDEA Older versions of IntelliJ IDEA Navigate to \"New Project\" from any view Select Gradle -> Java as the type of Project and make sure the correct JDK is selected (Java 8 or higher) Provide a title for your project and define your GroupId and optionally the ArtifactId and initial Version in the \"Artifact Coordinates\" subsection Optionally enable Auto-Importing of the Gradle file in the Gradle settings. This is also the place where you could switch the runner for your project (By default, Gradle is used to run your application and tests) Let IntelliJ index your project. Open build.gradle Populate the build file with the following plugins { id 'application' id 'com.github.johnrengelman.shadow' version '5.2.0' } mainClassName = 'com.example.jda.Bot' // (1) version '1.0' def jdaVersion = 'JDA_VERSION_HERE' // (2) sourceCompatibility = targetCompatibility = 1.8 repositories { mavenCentral () } dependencies { implementation ( \"net.dv8tion:JDA:$jdaVersion\" ) } compileJava . options . encoding = 'UTF-8' Replace the mainClassName value with the path to your main class later on! Replace the JDA_VERSION_HERE with the one mentioned in the latest release If IntelliJ IDEA didn't already do so automatically, set up a source folder as src/main/java Create your group package. Example: me.name.bot Make your main class. Example: Bot.java . Your directory tree should look like this: ProjectName -> src/main/java -> me/name/bot -> Bot.java -> gradle/wrapper -> gradle-wrapper.properties -> gradle/wrapper -> gradle-wrapper.jar -> build.gradle -> settings.gradle Configure the mainClassName value in the build.gradle to your class. Example: me.name.bot.Bot To build your finished project simply use the shadowJar task in your Gradle tool window on right hand side of your editor. This will build a jar in build/libs . The one with the -all suffix is the shadow jar. > You can also run your project with the run Gradle task! Setup Logback Continue with Getting Started Open the Project view Create a new Project Select Gradle > Java Configure your SDK to use Java 1.8 Click Next and fill in your groupId and your artifactId. Example: me.name and bot Check Use auto-import and click Next > Finish","title":"IntelliJ IDEA Setup"},{"location":"setup/logging/","text":"When you setup a JDA project you should also setup a logging implementation for SLF4J. This is only necessary if you get a warning like this on startup: SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\". SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details. I recommend logback-classic as it is my goto implementation. First add logback to your dependencies: Gradle Maven dependencies { implementation ( \"ch.qos.logback:logback-classic:1.2.8\" ) } <dependency> <groupId> ch.qos.logback </groupId> <artifactId> logback-classic </artifactId> <version> 1.2.8 </version> </dependency> Configure Logback \u00b6 The logback configuration needs to be in your resources directory. This is src/main/resources in all standard Gradle and Maven projects. Add the following configuration into src/main/resources/logback.xml : <?xml version=\"1.0\" encoding=\"UTF-8\"?> <configuration> <appender name= \"STDOUT\" class= \"ch.qos.logback.core.ConsoleAppender\" > <encoder> <pattern> %d{HH:mm:ss.SSS} %boldCyan(%-34.-34thread) %red(%10.10X{jda.shard}) %boldGreen(%-15.-15logger{0}) %highlight(%-6level) %msg%n </pattern> </encoder> </appender> <root level= \"info\" > <appender-ref ref= \"STDOUT\" /> </root> </configuration> You can read up on how this configuration works in the logback manual . How to enable debug logs \u00b6 In the config above, change the level for the root logger to debug: <root level= \"debug\" > ... </root> Supported MDC Options \u00b6 There are a few built-in MDC options used by JDA: jda.shard The shard id and shard total in the format [id / total] . (This is 0-based so with a total of 10 the last shard id [9 / 10] ) jda.shard.id The shard id jda.shard.total The shard total You can further configure other MDC variables for JDA threads with JDABuilder.setContextMap !","title":"Logging (SLF4J)"},{"location":"setup/logging/#configure-logback","text":"The logback configuration needs to be in your resources directory. This is src/main/resources in all standard Gradle and Maven projects. Add the following configuration into src/main/resources/logback.xml : <?xml version=\"1.0\" encoding=\"UTF-8\"?> <configuration> <appender name= \"STDOUT\" class= \"ch.qos.logback.core.ConsoleAppender\" > <encoder> <pattern> %d{HH:mm:ss.SSS} %boldCyan(%-34.-34thread) %red(%10.10X{jda.shard}) %boldGreen(%-15.-15logger{0}) %highlight(%-6level) %msg%n </pattern> </encoder> </appender> <root level= \"info\" > <appender-ref ref= \"STDOUT\" /> </root> </configuration> You can read up on how this configuration works in the logback manual .","title":"Configure Logback"},{"location":"setup/logging/#how-to-enable-debug-logs","text":"In the config above, change the level for the root logger to debug: <root level= \"debug\" > ... </root>","title":"How to enable debug logs"},{"location":"setup/logging/#supported-mdc-options","text":"There are a few built-in MDC options used by JDA: jda.shard The shard id and shard total in the format [id / total] . (This is 0-based so with a total of 10 the last shard id [9 / 10] ) jda.shard.id The shard id jda.shard.total The shard total You can further configure other MDC variables for JDA threads with JDABuilder.setContextMap !","title":"Supported MDC Options"},{"location":"setup/netbeans/","text":"Netbeans Setup \u00b6 Maven Setup Jar Setup Make a new Maven Java Application Open up the pom.xml in the Project Files Add JDA as a dependency Note These can go anywhere within the <project></project> tags. <dependencies> <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> 5.0.0-beta.1 </version> </dependency> </dependencies> Setup Logback Continue with Getting Started Download the latest (binary) version of JDA (with dependencies), as well as the javadocs https://ci.dv8tion.net/job/JDA5/ Make a new Java Application Right-click the Libraries folder in your project, and select Add JAR/Folder... Find the JDA...withDependencies.jar and add it. Right-click on the newly-added Jar file, and select Edit... Select Browse... and add the javadoc jar Setup Logback Continue with Getting Started","title":"Netbeans Setup"},{"location":"setup/netbeans/#netbeans-setup","text":"Maven Setup Jar Setup Make a new Maven Java Application Open up the pom.xml in the Project Files Add JDA as a dependency Note These can go anywhere within the <project></project> tags. <dependencies> <dependency> <groupId> net.dv8tion </groupId> <artifactId> JDA </artifactId> <version> 5.0.0-beta.1 </version> </dependency> </dependencies> Setup Logback Continue with Getting Started Download the latest (binary) version of JDA (with dependencies), as well as the javadocs https://ci.dv8tion.net/job/JDA5/ Make a new Java Application Right-click the Libraries folder in your project, and select Add JAR/Folder... Find the JDA...withDependencies.jar and add it. Right-click on the newly-added Jar file, and select Edit... Select Browse... and add the javadoc jar Setup Logback Continue with Getting Started","title":"Netbeans Setup"},{"location":"using-jda/gateway-intents-and-member-cache-policy/","text":"Gateway Intents \u00b6 In version 4.2.0 , we introduced the GatewayIntent enum. This marks a change in the way bots will work in the future. Building JDA is done using one of the JDABuilder factory methods, each of which has some default intents: createDefault createLight create What Intents do I need? \u00b6 The necessary intents directly correlate with the features you intend to use. Each GatewayIntent documents which events are enabled by it. Some caches in JDA also depend on these intents, so take a close look at the documentation for CacheFlag as well. For instance, a bot that only responds to messages and sends welcome messages will only need GUILD_MESSAGES , MESSAGE_CONTENT , and GUILD_MEMBERS . A bot like this doesn't rely on any members being cached, so the right solution is to use createLight which will disable all CacheFlags and member caching. public static void main ( String [] args ) { // createLight disables unused cache flags // GUILD_MESSAGES enables events for messages sent in guilds // MESSAGE_CONTENT enables access to the content of messages sent by other users // GUILD_MEMBERS gives you access to guild member join events so you can send welcome messages // The resulting JDA instance will not cache any members since createLight disables it. JDABuilder . createLight ( BOT_TOKEN , GatewayIntent . GUILD_MESSAGES , GatewayIntent . MESSAGE_CONTENT , GatewayIntent . GUILD_MEMBERS ) . addEventListeners ( new JoinListener ()) . addEventListeners ( new CommandHandler ()) . build (); } Due to GUILD_MEMBERS and MESSAGE_CONTENT being a privileged intents, you must also enable it in your developer dashboard: Open the application dashboard Select your bot application Open the Bot tab Under the Privileged Gateway Intents section, enable SERVER MEMBERS INTENT and MESSAGE CONTENT INTENT . If you use these intents, you are limited to 100 guilds on your bot. To allow the bot to join more guilds while using this intent, you have to verify your bot . This will be available in your application dashboard when the bot joins at least 76 guilds. You can also choose to just use createLight or createDefault without specifying the intents you need. In that case, JDA will just use GatewayIntent.DEFAULT . If you want to use the default but also include some additional intents like GUILD_MEMBERS then you can use enableIntents : JDABuilder . createDefault ( token ) // enable all default intents . enableIntents ( GatewayIntent . GUILD_MEMBERS ) // also enable privileged intent . addEventListeners ( new JoinListener ()) . addEventListeners ( new CommandHandler ()) . build (); Troubleshooting \u00b6 I'm getting CloseCode(4014 / Disallowed intents...) My event listener code is not executed Cannot get message content / Attempting to access message content without GatewayIntent CacheFlags \u00b6 JDA provides a number of different optional caches you can enable or disable. Most of these caches are configured using the CacheFlag enum. You can manually enable or disable these caches by using enableCache and disableCache respectively. Each createX factory method on the JDABuilder also configures a set of enabled flags automatically, based on your choice of intents. The CacheFlag enum documents which intents are required to use it and JDA will automatically disable them if the required intent is missing. If a flag is automatically disabled due to a missing intent, we print a warning telling you it was disabled and which intent was missing. To remove this warning, you have to explicitly disable the CacheFlag by using disableCache or, if you need the cache, enable the intent using enableIntents . The individual factory methods document which defaults will be used: createDefault createLight create MemberCachePolicy \u00b6 Together with intents, Discord now wants to further restrict data access for bots by limiting how many members they can cache. To properly maintain a cache of all members, you need the GUILD_MEMBERS intent, because it will enable the GuildMemberRemoveEvent to remove members from cache once they leave the guild. Without this intent, JDA would infinitely grow its cache without knowing when to remove members. To handle this new default, we now have a MemberCachePolicy which can be configured using setMemberCachePolicy . Each factory method will set a default cache policy which will only retain members under certain conditions: createLight Will only cache the self member createDefault Will only cache members who are connected to a voice channel, the guild owner, and the self member create Will cache all members it can properly track. See the docs for further details. We also provide a few reasonable implementations to choose from and apply using setMemberCachePolicy : All Will keep all members cached (requires GUILD_MEMBERS intents) Online Will keep all online members cached (requires GUILD_PRESENCES intent) Voice Will keep all voice members cached (requires GUILD_VOICE_STATES intent) Owner Will keep the guild owner cached Pending Will cache the members which have not passed membership screening yet (requires GUILD_MEMBERS intents) None Will only keep the self member cached and nobody else It is important to understand the difference between cache and load in this system. JDABuilder . createDefault ( token ) . enableIntents ( GatewayIntent . GUILD_MEMBERS ) . setMemberCachePolicy ( MemberCachePolicy . ALL ) . build (); The difference becomes clear when you try to access the member list using this configuration. The MemberCachePolicy.ALL will specifically cache all members once they are loaded . However, we are lazy loading members and start off with only a small subset of all members in cache. This cache will grow over time by loading members when they are active in the guilds, such as sending a message or connecting to a voice channel. Loading Members \u00b6 We offer a number of ways to load and cache members: Guild.retrieveMembersByPrefix(String, int) Guild.retrieveOwner() Guild.retrieveMemberById(long|String) Guild.retrieveMembersByIds(long...|String..) Guild.retrieveMembers(Collection<User>) Message.getMember() (from events) All of these methods will load the members from cache or fallback to requesting them from the Discord API. You can also load the entire member list at runtime by using loadMembers , however this requires the privileged GUILD_MEMBERS intent. This process is called guild member chunking (aka chunking). Chunking can also be performed for many guilds at startup automatically, by using setChunkingFilter on the JDABuilder. This also requires the GUILD_MEMBERS intent","title":"Gateway Intents and Member Cache Policy"},{"location":"using-jda/gateway-intents-and-member-cache-policy/#gateway-intents","text":"In version 4.2.0 , we introduced the GatewayIntent enum. This marks a change in the way bots will work in the future. Building JDA is done using one of the JDABuilder factory methods, each of which has some default intents: createDefault createLight create","title":"Gateway Intents"},{"location":"using-jda/gateway-intents-and-member-cache-policy/#what-intents-do-i-need","text":"The necessary intents directly correlate with the features you intend to use. Each GatewayIntent documents which events are enabled by it. Some caches in JDA also depend on these intents, so take a close look at the documentation for CacheFlag as well. For instance, a bot that only responds to messages and sends welcome messages will only need GUILD_MESSAGES , MESSAGE_CONTENT , and GUILD_MEMBERS . A bot like this doesn't rely on any members being cached, so the right solution is to use createLight which will disable all CacheFlags and member caching. public static void main ( String [] args ) { // createLight disables unused cache flags // GUILD_MESSAGES enables events for messages sent in guilds // MESSAGE_CONTENT enables access to the content of messages sent by other users // GUILD_MEMBERS gives you access to guild member join events so you can send welcome messages // The resulting JDA instance will not cache any members since createLight disables it. JDABuilder . createLight ( BOT_TOKEN , GatewayIntent . GUILD_MESSAGES , GatewayIntent . MESSAGE_CONTENT , GatewayIntent . GUILD_MEMBERS ) . addEventListeners ( new JoinListener ()) . addEventListeners ( new CommandHandler ()) . build (); } Due to GUILD_MEMBERS and MESSAGE_CONTENT being a privileged intents, you must also enable it in your developer dashboard: Open the application dashboard Select your bot application Open the Bot tab Under the Privileged Gateway Intents section, enable SERVER MEMBERS INTENT and MESSAGE CONTENT INTENT . If you use these intents, you are limited to 100 guilds on your bot. To allow the bot to join more guilds while using this intent, you have to verify your bot . This will be available in your application dashboard when the bot joins at least 76 guilds. You can also choose to just use createLight or createDefault without specifying the intents you need. In that case, JDA will just use GatewayIntent.DEFAULT . If you want to use the default but also include some additional intents like GUILD_MEMBERS then you can use enableIntents : JDABuilder . createDefault ( token ) // enable all default intents . enableIntents ( GatewayIntent . GUILD_MEMBERS ) // also enable privileged intent . addEventListeners ( new JoinListener ()) . addEventListeners ( new CommandHandler ()) . build ();","title":"What Intents do I need?"},{"location":"using-jda/gateway-intents-and-member-cache-policy/#troubleshooting","text":"I'm getting CloseCode(4014 / Disallowed intents...) My event listener code is not executed Cannot get message content / Attempting to access message content without GatewayIntent","title":"Troubleshooting"},{"location":"using-jda/gateway-intents-and-member-cache-policy/#cacheflags","text":"JDA provides a number of different optional caches you can enable or disable. Most of these caches are configured using the CacheFlag enum. You can manually enable or disable these caches by using enableCache and disableCache respectively. Each createX factory method on the JDABuilder also configures a set of enabled flags automatically, based on your choice of intents. The CacheFlag enum documents which intents are required to use it and JDA will automatically disable them if the required intent is missing. If a flag is automatically disabled due to a missing intent, we print a warning telling you it was disabled and which intent was missing. To remove this warning, you have to explicitly disable the CacheFlag by using disableCache or, if you need the cache, enable the intent using enableIntents . The individual factory methods document which defaults will be used: createDefault createLight create","title":"CacheFlags"},{"location":"using-jda/gateway-intents-and-member-cache-policy/#membercachepolicy","text":"Together with intents, Discord now wants to further restrict data access for bots by limiting how many members they can cache. To properly maintain a cache of all members, you need the GUILD_MEMBERS intent, because it will enable the GuildMemberRemoveEvent to remove members from cache once they leave the guild. Without this intent, JDA would infinitely grow its cache without knowing when to remove members. To handle this new default, we now have a MemberCachePolicy which can be configured using setMemberCachePolicy . Each factory method will set a default cache policy which will only retain members under certain conditions: createLight Will only cache the self member createDefault Will only cache members who are connected to a voice channel, the guild owner, and the self member create Will cache all members it can properly track. See the docs for further details. We also provide a few reasonable implementations to choose from and apply using setMemberCachePolicy : All Will keep all members cached (requires GUILD_MEMBERS intents) Online Will keep all online members cached (requires GUILD_PRESENCES intent) Voice Will keep all voice members cached (requires GUILD_VOICE_STATES intent) Owner Will keep the guild owner cached Pending Will cache the members which have not passed membership screening yet (requires GUILD_MEMBERS intents) None Will only keep the self member cached and nobody else It is important to understand the difference between cache and load in this system. JDABuilder . createDefault ( token ) . enableIntents ( GatewayIntent . GUILD_MEMBERS ) . setMemberCachePolicy ( MemberCachePolicy . ALL ) . build (); The difference becomes clear when you try to access the member list using this configuration. The MemberCachePolicy.ALL will specifically cache all members once they are loaded . However, we are lazy loading members and start off with only a small subset of all members in cache. This cache will grow over time by loading members when they are active in the guilds, such as sending a message or connecting to a voice channel.","title":"MemberCachePolicy"},{"location":"using-jda/gateway-intents-and-member-cache-policy/#loading-members","text":"We offer a number of ways to load and cache members: Guild.retrieveMembersByPrefix(String, int) Guild.retrieveOwner() Guild.retrieveMemberById(long|String) Guild.retrieveMembersByIds(long...|String..) Guild.retrieveMembers(Collection<User>) Message.getMember() (from events) All of these methods will load the members from cache or fallback to requesting them from the Discord API. You can also load the entire member list at runtime by using loadMembers , however this requires the privileged GUILD_MEMBERS intent. This process is called guild member chunking (aka chunking). Chunking can also be performed for many guilds at startup automatically, by using setChunkingFilter on the JDABuilder. This also requires the GUILD_MEMBERS intent","title":"Loading Members"},{"location":"using-jda/getting-started/","text":"Making a Ping-Pong Bot \u00b6 Creating a Discord Bot \u00b6 Go to https://discord.com/developers/applications Create an Application Give the application an awesome name (this will be used as the bots initial username) Click Save Changes Open the Bot tab Click Add Bot and confirm Make sure to make your bot public, this allows others to invite your bot to your server. You only want require code grant enabled if you plan to use an oauth2 flow, the general user will not need this. Add your Discord Bot to a Server \u00b6 Retrieve your application/client ID from the General Information tab Create an OAuth2 authorization URL (reference docs ). Users who want to use Interaction Commands should also add the applications.commands scope. Some example URLs: https://discord.com/api/oauth2/authorize?client_id=492747769036013578&scope=bot https://discord.com/api/oauth2/authorize?client_id=492747769036013578&scope=bot+applications.commands Note This can be done from the Bot tab at the very bottom. Here you can select the scope bot and some permissions required for your bots functionality (optional). Open the authorization dialogue (click link from step 2) Select your Server (Requires permission to manage server) Click Authorize Connecting to Discord with a Bot Account \u00b6 Retrieve your Bot Token from your application dashboard (https://discord.com/developers/applications) Caution Note that it is very important not to show this token to anyone, ever. Set up your JDA project: IntelliJ IDEA Eclipse Netbeans Create JDABuilder instance with token Build JDA using JDABuilder.build() public static void main ( String [] arguments ) throws Exception { JDA api = JDABuilder . createDefault ( BOT_TOKEN ). build (); } Tip It is often better to load your token in from an external file or environment variable, especially if you plan on publishing the source code. Making a Ping-Pong Protocol \u00b6 Setup your JDA instance (see Connecting To Discord ) Implement an EventListener or extend ListenerAdapter public class MyListener extends ListenerAdapter { @Override public void onMessageReceived ( MessageReceivedEvent event ) { if ( event . getAuthor (). isBot ()) return ; // We don't want to respond to other bot accounts, including ourself Message message = event . getMessage (); String content = message . getContentRaw (); // getContentRaw() is an atomic getter // getContentDisplay() is a lazy getter which modifies the content for e.g. console view (strip discord formatting) if ( content . equals ( \"!ping\" )) { MessageChannel channel = event . getChannel (); channel . sendMessage ( \"Pong!\" ). queue (); // Important to call .queue() on the RestAction returned by sendMessage(...) } } } Info More information about RestActions can be found here Register your listener with either JDABuilder.addEventListeners(new MyListener()) or JDA.addEventListeners(new MyListener()) (see Events )","title":"Getting Started"},{"location":"using-jda/getting-started/#making-a-ping-pong-bot","text":"","title":"Making a Ping-Pong Bot"},{"location":"using-jda/getting-started/#creating-a-discord-bot","text":"Go to https://discord.com/developers/applications Create an Application Give the application an awesome name (this will be used as the bots initial username) Click Save Changes Open the Bot tab Click Add Bot and confirm Make sure to make your bot public, this allows others to invite your bot to your server. You only want require code grant enabled if you plan to use an oauth2 flow, the general user will not need this.","title":"Creating a Discord Bot"},{"location":"using-jda/getting-started/#add-your-discord-bot-to-a-server","text":"Retrieve your application/client ID from the General Information tab Create an OAuth2 authorization URL (reference docs ). Users who want to use Interaction Commands should also add the applications.commands scope. Some example URLs: https://discord.com/api/oauth2/authorize?client_id=492747769036013578&scope=bot https://discord.com/api/oauth2/authorize?client_id=492747769036013578&scope=bot+applications.commands Note This can be done from the Bot tab at the very bottom. Here you can select the scope bot and some permissions required for your bots functionality (optional). Open the authorization dialogue (click link from step 2) Select your Server (Requires permission to manage server) Click Authorize","title":"Add your Discord Bot to a Server"},{"location":"using-jda/getting-started/#connecting-to-discord-with-a-bot-account","text":"Retrieve your Bot Token from your application dashboard (https://discord.com/developers/applications) Caution Note that it is very important not to show this token to anyone, ever. Set up your JDA project: IntelliJ IDEA Eclipse Netbeans Create JDABuilder instance with token Build JDA using JDABuilder.build() public static void main ( String [] arguments ) throws Exception { JDA api = JDABuilder . createDefault ( BOT_TOKEN ). build (); } Tip It is often better to load your token in from an external file or environment variable, especially if you plan on publishing the source code.","title":"Connecting to Discord with a Bot Account"},{"location":"using-jda/getting-started/#making-a-ping-pong-protocol","text":"Setup your JDA instance (see Connecting To Discord ) Implement an EventListener or extend ListenerAdapter public class MyListener extends ListenerAdapter { @Override public void onMessageReceived ( MessageReceivedEvent event ) { if ( event . getAuthor (). isBot ()) return ; // We don't want to respond to other bot accounts, including ourself Message message = event . getMessage (); String content = message . getContentRaw (); // getContentRaw() is an atomic getter // getContentDisplay() is a lazy getter which modifies the content for e.g. console view (strip discord formatting) if ( content . equals ( \"!ping\" )) { MessageChannel channel = event . getChannel (); channel . sendMessage ( \"Pong!\" ). queue (); // Important to call .queue() on the RestAction returned by sendMessage(...) } } } Info More information about RestActions can be found here Register your listener with either JDABuilder.addEventListeners(new MyListener()) or JDA.addEventListeners(new MyListener()) (see Events )","title":"Making a Ping-Pong Protocol"},{"location":"using-jda/interactions/","text":"Interactions \u00b6 Interactions differ between JDA v4 and JDA v5. This page covers JDA v5. This guide will give you a brief introduction to an API for adding and handling interactions in Discord. Interactions are a way to integrate your bot features directly into the Discord User Interface. These things include features such as: Slash Commands Slash Command Autocomplete Context Menus Buttons Select Menus (Dropdowns) Modals Ephemeral Messages \u00b6 Ephemeral messages are only visible to the user who used your Interaction. They are similar to the messages Discord sends you when you update your nickname with /nick . There are many limitations to ephemeral messages, a few of which are listed below: Cannot be reacted to Cannot be retrieved Will be removed after a client restart Example You can only create ephemeral messages with interactions. For example with deferReply(true) , reply(content).setEphemeral(true) , or getHook().sendMessage(content).setEphemeral(true) . For convenience, you can also configure the InteractionHook to default to ephemeral messages with hook.setEphemeral(true) . Command Interactions \u00b6 Slash Commands \u00b6 A slash command is something you might already be familiar with from the olden times of Discord. Commands such as /shrug or /me have existed for quite a long time. With Slash Command interactions you can now make your very own commands like this! But these commands come with some limitations, which I have explained in this gist: Slash Command Limitations All of these commands are used through the interactions API. They do not require the user to send an actual message in the channel and you don't have to do string parsing either. To create commands you need to make some API requests. There are 2 types of commands you can create called global commands and guild commands . Global : These commands are available in every server your bot is in (regardless of sharding!) and direct message (Private Channels). Guild : These commands are only in the specific guild that you created them in and cannot be used in direct messages. Creating Slash Commands \u00b6 You can create commands through these methods in JDA: updateCommands() upsertCommand(name, description) Example Java Kotlin guild . updateCommands (). addCommands ( Commands . slash ( \"echo\" , \"Repeats messages back to you.\" ) . addOption ( OptionType . STRING , \"message\" , \"The message to repeat.\" ) . addOption ( OptionType . INTEGER , \"times\" , \"The number of times to repeat the message.\" ) . addOption ( OptionType . BOOLEAN , \"ephemeral\" , \"Whether or not the message should be sent as an ephemeral message.\" ), Commands . slash ( \"animal\" , \"Finds a random animal\" ) . addOptions ( new OptionData ( OptionType . STRING , \"type\" , \"The type of animal to find\" ) . addChoice ( \"Bird\" , \"bird\" ) . addChoice ( \"Big Cat\" , \"bigcat\" ) . addChoice ( \"Canine\" , \"canine\" ) . addChoice ( \"Fish\" , \"fish\" ) ) ). queue (); guild . updateCommands (). addCommands ( Commands . slash ( \"echo\" , \"Repeats messages back to you.\" ) . addOption ( OptionType . STRING , \"message\" , \"The message to repeat.\" ) . addOption ( OptionType . INTEGER , \"times\" , \"The number of times to repeat the message.\" ) . addOption ( OptionType . BOOLEAN , \"ephemeral\" , \"Whether or not the message should be sent as an ephemeral message.\" ), Commands . slash ( \"animal\" , \"Finds a random animal\" ) . addOptions ( OptionData ( OptionType . STRING , \"type\" , \"The type of animal to find\" ) . addChoice ( \"Bird\" , \"bird\" ) . addChoice ( \"Big Cat\" , \"bigcat\" ) . addChoice ( \"Canine\" , \"canine\" ) . addChoice ( \"Fish\" , \"fish\" ) ) ). queue () You need to call these on a JDA instance to create global commands, and on a Guild instance to create guild commands . Your bot needs the applications.commands scope in addition to the bot scope for your bot invite link. Example: https://discord.com/oauth2/authorize?client_id=123456789&scope=bot+applications.commands Warning If the applications.commands scope is not present, JDA will fail to create guild commands, and global commands will not be shown in the client. Once a command is created, it will continue persisting even when your bot restarts. Commands stay until the bot is either kicked or your bot explicitly deletes the command. You don't need to create your commands every time your bot starts! Responding to Slash Commands \u00b6 When a user tries to use one of your commands you will receive a SlashCommandInteractionEvent . This event needs to be handled by your event listener. The flow of a slash command response is as follows: Acknowledge the command This means you need to either reply or deferReply . You only have 3 SECONDS to acknowledge a command. Since some commands may take longer than 3 seconds you may want to use deferReply to have more time for handling. This will instead send a Thinking... message to channel which is later updated by a followup message (see step 2). Send followup messages Sometimes commands need more than one response. However, you can only send one initial reply to a command. To send additional messages for the same slash command you need to use the InteractionHook attached to the event with getHook() . This is a webhook that allows you to send additional messages for up to 15 minutes after the initial command. When you use deferReply the first message sent to this webhook will act identically to using editOriginal(...) . The message you send is also referred to as deferred reply in this case. Your deferred reply will edit your initial Thinking... message instead of sending an additional message to channel. This means you cannot use setEphemeral on this deferred reply since you already decided whether the message will be ephemeral through your initial acknowledgment. Example Reply Java Kotlin public class SayCommand extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"say\" )) { event . reply ( event . getOption ( \"content\" ). getAsString ()). queue (); // reply immediately } } } object SayCommand : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"say\" ) { event . reply ( event . getOption ( \"content\" ) !! . asString ). queue () } } } Example Deferred Reply Java Kotlin public class TagCommand extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"tag\" )) { event . deferReply (). queue (); // Tell discord we received the command, send a thinking... message to the user String tagName = event . getOption ( \"name\" ). getAsString (); TagDatabase . fingTag ( tagName , ( tag ) -> event . getHook (). sendMessage ( tag ). queue () // delayed response updates our inital \"thinking...\" message with the tag value ); } } } object TagCommand : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"tag\" ) { event . deferReply (). queue () // Tell discord we received the command, send a thinking... message to the user val tagName = event . getOption ( \"name\" ) !! . asString TagDatabase . fingTag ( tagName ) { tag -> event . hook . sendMessage ( tag ). queue () // delayed response updates our inital \"thinking...\" message with the tag value } } } } Managing Slash Command Permissions \u00b6 Restricting slash commands to specific roles or members is up to the admins of the guild. However, bots can specify a set of permissions that sets who can use those commands by default. Note that members with Permission.ADMINISTRATOR can always use commands, and they can override which roles or members can run the command. JDA only changes the default members and roles that can access it. In order to set this default, .setDefaultPermissions() can be called on the command before you register it. DefaultMemberPermissions.DISABLED can be used to only allow administrators by default, and DefaultMemberPermissions.ENABLED can be used to allow all members by default. Example This will restrict the command so that only members with the Permission.MANAGE_CHANNEL and Permission.MODERATE_MEMBERS permissions can use the command: Java Kotlin guild . updateCommands (). addCommands ( Commands . slash ( \"meeting\" , \"Creates a new channel for an emergency meeting\" ) . setDefaultPermissions ( DefaultMemberPermissions . enabledFor ( Permission . MANAGE_CHANNEL , Permission . MODERATE_MEMBERS )) ). queue (); guild . updateCommands (). addCommands ( Commands . slash ( \"meeting\" , \"Creates a new channel for an emergency meeting\" ) . setDefaultPermissions ( DefaultMemberPermissions . enabledFor ( Permission . MANAGE_CHANNEL , Permission . MODERATE_MEMBERS )) ). queue () Slash Command Autocomplete \u00b6 Slash command autocompletion is a feature that allows users to begin typing arguments to a command, and suggestions from the bot will be displayed to the user, in-client. Any slash command arguments using the String , Integer or Number types can be autocompleted. By default, options are not autocompleted. In order to make an option autocompleted, OptionData#setAutoComplete(true) may be used. Handling Autocomplete \u00b6 As the user is typing an argument that has autocomplete enabled for it, the bot will receive an CommandAutoCompleteInteractionEvent . This event isn't fired for each keystroke, but is sent when Discord determines the user has paused typing for a bit. Autocompletions can suggest up to 25 options, and users do not have to send a command with one of the options. Example Creating the command: Java Kotlin guild . updateCommands (). addCommands ( Commands . slash ( \"fruit\" , \"find a given fruit\" ) . addOption ( OptionType . STRING , \"name\" , \"fruit to find\" , true , true ) ). queue (); guild . updateCommands (). addCommands ( Commands . slash ( \"fruit\" , \"find a given fruit\" ) . addOption ( OptionType . STRING , \"name\" , \"fruit to find\" , required = true , autocomplete = true ) ). queue () Handling the event: Java Kotlin AutoCompleteBot.java public class AutoCompleteBot extends ListenerAdapter { private String [] words = new String [] { \"apple\" , \"apricot\" , \"banana\" , \"cherry\" , \"coconut\" , \"cranberry\" }; @Override public void onCommandAutoCompleteInteraction ( CommandAutoCompleteInteractionEvent event ) { if ( event . getName (). equals ( \"fruit\" ) && event . getFocusedOption (). getName (). equals ( \"name\" )) { List < Command . Choice > options = Stream . of ( words ) . filter ( word -> word . startsWith ( event . getFocusedOption (). getValue ())) // only display words that start with the user's current input . map ( word -> new Command . Choice ( word , word )) // map the words to choices . collect ( Collectors . toList ()); event . replyChoices ( options ). queue (); } } } AutoCompleteBot.kt object AutoCompleteBot : ListenerAdapter () { private val words = arrayOf ( \"apple\" , \"apricot\" , \"banana\" , \"cherry\" , \"coconut\" , \"cranberry\" ) override fun onCommandAutoCompleteInteraction ( event : CommandAutoCompleteInteractionEvent ) { if ( event . name == \"fruit\" && event . focusedOption . name == \"name\" ) { event . replyChoiceStrings ( words . filter { it . startsWith ( event . focusedOption . value ) }). queue () } } } Context Menus \u00b6 Context Menu commands are a special type of command that can be invoked on a user or message by right-clicking on them. These commands take no arguments, and are useful for providing a quick way to perform actions on a user or message. Example Creating the commands: guild . updateCommands (). addCommands ( Commands . context ( Command . Type . USER , \"Get user avatar\" ), Commands . message ( \"Count words\" ) ). queue () Handling the events: Java Kotlin ContextMenuBot.java public class ContextMenuBot extends ListenerAdapter { @Override public void onUserContextInteraction ( UserContextInteractionEvent event ) { if ( event . getName (). equals ( \"Get user avatar\" )) { event . reply ( \"Avatar: \" + event . getTarget (). getEffectiveAvatarUrl ()). queue (); } } @Override public void onMessageContextInteraction ( MessageContextInteractionEvent event ) { if ( event . getName (). equals ( \"Count words\" )) { event . reply ( \"Words: \" + event . getTarget (). getContentRaw (). split ( \"\\\\s+\" ). length ). queue (); } } } ContextMenuBot.kt object ContextMenuBot : ListenerAdapter () { override fun onUserContextInteraction ( event : UserContextInteractionEvent ) { if ( event . name == \"Get user avatar\" ) { event . reply ( \"Avatar: \" + event . target . effectiveAvatarUrl ). queue () } } override fun onMessageContextInteraction ( event : MessageContextInteractionEvent ) { if ( event . name == \"Count words\" ) { event . reply ( \"Words: \" + event . target . contentRaw . split ( Regex ( \"\\\\s+\" )). size ). queue () } } } Component Interactions \u00b6 To add components to a message you can use up to 5 ActionRows. You can add multiple ActionRows with either setComponents or addComponents . For the common case of a single ActionRow you can also use setActionRow(Component...) or addActionRow(Component...) . Each ActionRow can hold up to a certain amount of components: 5 Buttons 1 Select Menu (Dropdown) 1 Text Input (Restricted to Modals) These component interactions offer 4 response types: Reply Deferred Reply Edit Message Deferred Edit Message The reply and deferred reply responses are identical to the Slash-Commands response types. However, these new edit response types are used to update the existing message the component is attached to. If you just want to acknowledge that the component was successfully interacted with, you can simply call deferEdit() without any further updates, which will prevent the interaction from failing on the user side. To properly use an interactive component, you need to use the Component ID (aka Custom ID ). This ID can also be used to then identify which component was pressed by the user. Such Component ID is provided by getComponentId() on every Component Interaction. Keep in mind that these Component IDs must be unique across all components in one message . Buttons \u00b6 Each button can be enabled or disabled, have a specific style, label, and emoji: Handling ButtonInteractionEvent \u00b6 When a user presses one of these buttons, you will receive a ButtonInteractionEvent for the respective interaction. Each non-link button requires such an ID in order to be used. Example Java Kotlin public class HelloBot extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"hello\" )) { event . reply ( \"Click the button to say hello\" ) . addActionRow ( Button . primary ( \"hello\" , \"Click Me\" ), // Button with only a label Button . success ( \"emoji\" , Emoji . fromFormatted ( \"<:minn:245267426227388416>\" ))) // Button with only an emoji . queue (); } else if ( event . getName (). equals ( \"info\" )) { event . reply ( \"Click the buttons for more info\" ) . addActionRow ( // link buttons don't send events, they just open a link in the browser when clicked Button . link ( \"https://github.com/DV8FromTheWorld/JDA\" , \"GitHub\" ) . withEmoji ( Emoji . fromFormatted ( \"<:github:849286315580719104>\" )), // Link Button with label and emoji Button . link ( \"https://ci.dv8tion.net/job/JDA/javadoc/\" , \"Javadocs\" )) // Link Button with only a label . queue (); } } @Override public void onButtonInteraction ( ButtonInteractionEvent event ) { if ( event . getComponentId (). equals ( \"hello\" )) { event . reply ( \"Hello :)\" ). queue (); // send a message in the channel } else if ( event . getComponentId (). equals ( \"emoji\" )) { event . editMessage ( \"That button didn't say click me\" ). queue (); // update the message } } } object HelloBot : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"hello\" ) { event . reply ( \"Click the button to say hello\" ) . addActionRow ( Button . primary ( \"hello\" , \"Click Me\" ), // Button with only a label Button . success ( \"emoji\" , Emoji . fromFormatted ( \"<:minn:245267426227388416>\" ))) // Button with only an emoji . queue () } else if ( event . name == \"info\" ) { event . reply ( \"Click the buttons for more info\" ) . addActionRow ( // link buttons don't send events, they just open a link in the browser when clicked Button . link ( \"https://github.com/DV8FromTheWorld/JDA\" , \"GitHub\" ) . withEmoji ( Emoji . fromFormatted ( \"<:github:849286315580719104>\" )), // Link Button with label and emoji Button . link ( \"https://ci.dv8tion.net/job/JDA/javadoc/\" , \"Javadocs\" )) // Link Button with only a label . queue () } } override fun onButtonInteraction ( event : ButtonInteractionEvent ) { when ( event . componentId ) { \"hello\" -> event . reply ( \"Hello :)\" ). queue () // send a message in the channel \"emoji\" -> event . editMessage ( \"That button didn't say click me\" ). queue () // update the message } } } Select Menus (Dropdowns) \u00b6 Select Menus can be disabled. It's possible to set the minimum and maximum number of options to be selected. There are two implementations for SelectMenus: StringSelectMenu supports custom string choices EntitySelectMenu derives its choices from mentionable entities (such as User s, Channel s, etc) String Select Menus \u00b6 String Select Menus support up to 25 options. Each option can have its own label, description, and emoji. There can be multiple options selected and set as default. Entity Select Menus \u00b6 Entity Select Menus do not support custom choices. Instead, they derive their choices from mentionable Discord entities such as User s, Channel s, etc. You can specify which entity types you wish to appear as choices by specifying the SelectTarget s in EntitySelectMenu.create . If you create an entity select menu with channel type targets, the same menu may not utilize user or role select targets, and vice versa. You can limit channel selections to specific channel types by using the setChannelTypes method on EntitySelectMenu.Builder . Info These Select Menus do not support setting a custom list of options or customizing the appearance in any way. They always show the complete list of possible entities for the specified types. Handling Select Menus \u00b6 When a user selects their options from a dropdown and submits their choices, you will receive either one of the following for the respective interaction: A StringSelectInteractionEvent for a String Select Menu interaction An EntitySelectInteractionEvent for an Entity Select Menu interaction Both interaction events provide the values that were selected by the user. Example String Select Handling Java Kotlin public class StringDropdownBot extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"food\" )) { event . reply ( \"Choose your favorite food\" ) . addActionRow ( StringSelectMenu . create ( \"choose-food\" ) . addOption ( \"Pizza\" , \"pizza\" , \"Classic\" ) // SelectOption with only the label, value, and description . addOptions ( SelectOption . of ( \"Hamburger\" , \"hamburger\" ) // another way to create a SelectOption . withDescription ( \"Tasty\" ) // this time with a description . withEmoji ( Emoji . fromUnicode ( \"\\uD83C\\uDF54\" )) // and an emoji . withDefault ( true )) // while also being the default option . build ()) . queue (); } } @Override public void onStringSelectInteraction ( StringSelectInteractionEvent event ) { if ( event . getComponentId (). equals ( \"choose-food\" )) { event . reply ( \"You chose \" + event . getValues (). get ( 0 )). queue (); } } } object StringDropdownBot : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"food\" ) { val selectMenu = StringSelectMenu . create ( \"choose-food\" ) . addOption ( \"Pizza\" , \"pizza\" , \"Classic\" ) // SelectOption with only the label, value, and description . addOptions ( SelectOption . of ( \"Hamburger\" , \"hamburger\" ) // another way to create a SelectOption . withDescription ( \"Tasty\" ) // this time with a description . withEmoji ( Emoji . fromUnicode ( \"\\uD83C\\uDF54\" )) // and an emoji . withDefault ( true )) // while also being the default option . build () event . reply ( \"Choose your favorite food\" ) . addActionRow ( selectMenu ) . queue () } } override fun onStringSelectInteraction ( event : StringSelectInteractionEvent ) { if ( event . componentId == \"choose-food\" ) { event . reply ( \"You chose \" + event . values [ 0 ] ). queue () } } } Example Entity Select Handling Java Kotlin public class EntityDropdownBot extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"highfive\" )) { event . reply ( \"Choose the user to high-five\" ) . addActionRow ( EntitySelectMenu . create ( \"choose-user\" , SelectTarget . USER ) . build ()) . queue (); } } @Override public void onEntitySelectInteraction ( EntitySelectInteractionEvent event ) { if ( event . getComponentId (). equals ( \"choose-user\" )) { // Mentions provide the selected values using familiar getters List < User > users = event . getMentions (). getUsers (); event . reply ( \"You high-fived \" + users . get ( 0 ). getAsMention ()). queue (); } } } object EntityDropdownBot : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"food\" ) { val selectMenu = EntitySelectMenu . create ( \"choose-user\" , SelectTarget . USER ) . build () event . reply ( \"Choose the user to high-five\" ) . addActionRow ( selectMenu ) . queue () } } override fun onEntitySelectInteraction ( event : EntitySelectInteractionEvent ) { if ( event . componentId == \"choose-user\" ) { // Mentions provide the selected values using familiar getters val users = event . mentions . users ; event . reply ( \"You high-fived \" + users . first (). asMention ). queue () } } } Modals \u00b6 Modals are pop-ups that appear in a user's Discord client. Similarly to messages, Modals can contain up to 5 ActionRows, although the only component that can be put inside Modals at the moment ( TextInput ) takes up a whole ActionRow. Replying with a Modal \u00b6 Example Java Kotlin public class SupportCommand extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"modmail\" )) { TextInput subject = TextInput . create ( \"subject\" , \"Subject\" , TextInputStyle . SHORT ) . setPlaceholder ( \"Subject of this ticket\" ) . setMinLength ( 10 ) . setMaxLength ( 100 ) // or setRequiredRange(10, 100) . build (); TextInput body = TextInput . create ( \"body\" , \"Body\" , TextInputStyle . PARAGRAPH ) . setPlaceholder ( \"Your concerns go here\" ) . setMinLength ( 30 ) . setMaxLength ( 1000 ) . build (); Modal modal = Modal . create ( \"modmail\" , \"Modmail\" ) . addComponents ( ActionRow . of ( subject ), ActionRow . of ( body )) . build (); event . replyModal ( modal ). queue (); } } } object SupportCommand : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"modmail\" ) { val subject = TextInput . create ( \"subject\" , \"Subject\" , TextInputStyle . SHORT ) . setPlaceholder ( \"Subject of this ticket\" ) . setMinLength ( 10 ) . setMaxLength ( 100 ) // or setRequiredRange(10, 100) . build () val body = TextInput . create ( \"body\" , \"Body\" , TextInputStyle . PARAGRAPH ) . setPlaceholder ( \"Your concerns go here\" ) . setMinLength ( 30 ) . setMaxLength ( 1000 ) . build () val modal = Modal . create ( \"modmail\" , \"Modmail\" ) . addComponents ( ActionRow . of ( subject ), ActionRow . of ( body )) . build () event . replyModal ( modal ). queue () } } } Handling ModalInteractionEvent \u00b6 When the user clicks the \"Submit\" button on the Modal, you will receive an ModalInteractionEvent , containing all the values the user put in it. Warning Acknowledging a ModalInteractionEvent is necessary. Failing to respond to the event will not close it on the user's client, and will show them an error. Info If the Modal originated from a Component-Interaction (Buttons, SelectMenus), it is possible to acknowledge the interaction using an edit to the original Message using editMessage() or similar. Example Java Kotlin public class ModalListener extends ListenerAdapter { @Override public void onModalInteraction ( @Nonnull ModalInteractionEvent event ) { if ( event . getModalId (). equals ( \"modmail\" )) { String subject = event . getValue ( \"subject\" ). getAsString (); String body = event . getValue ( \"body\" ). getAsString (); createSupportTicket ( subject , body ); event . reply ( \"Thanks for your request!\" ). setEphemeral ( true ). queue (); } } } object ModalListener : ListenerAdapter () { override fun onModalInteraction ( event : ModalInteractionEvent ) { if ( event . modalId == \"modmail\" ) { val subject = event . getValue ( \"subject\" ) ?: return val body = event . getValue ( \"body\" ) ?: return createSupportTicket ( subject , body ) event . reply ( \"Thanks for your request!\" ). setEphemeral ( true ). queue () } } }","title":"Interactions"},{"location":"using-jda/interactions/#interactions","text":"Interactions differ between JDA v4 and JDA v5. This page covers JDA v5. This guide will give you a brief introduction to an API for adding and handling interactions in Discord. Interactions are a way to integrate your bot features directly into the Discord User Interface. These things include features such as: Slash Commands Slash Command Autocomplete Context Menus Buttons Select Menus (Dropdowns) Modals","title":"Interactions"},{"location":"using-jda/interactions/#ephemeral-messages","text":"Ephemeral messages are only visible to the user who used your Interaction. They are similar to the messages Discord sends you when you update your nickname with /nick . There are many limitations to ephemeral messages, a few of which are listed below: Cannot be reacted to Cannot be retrieved Will be removed after a client restart Example You can only create ephemeral messages with interactions. For example with deferReply(true) , reply(content).setEphemeral(true) , or getHook().sendMessage(content).setEphemeral(true) . For convenience, you can also configure the InteractionHook to default to ephemeral messages with hook.setEphemeral(true) .","title":"Ephemeral Messages"},{"location":"using-jda/interactions/#command-interactions","text":"","title":"Command Interactions"},{"location":"using-jda/interactions/#slash-commands","text":"A slash command is something you might already be familiar with from the olden times of Discord. Commands such as /shrug or /me have existed for quite a long time. With Slash Command interactions you can now make your very own commands like this! But these commands come with some limitations, which I have explained in this gist: Slash Command Limitations All of these commands are used through the interactions API. They do not require the user to send an actual message in the channel and you don't have to do string parsing either. To create commands you need to make some API requests. There are 2 types of commands you can create called global commands and guild commands . Global : These commands are available in every server your bot is in (regardless of sharding!) and direct message (Private Channels). Guild : These commands are only in the specific guild that you created them in and cannot be used in direct messages.","title":"Slash Commands"},{"location":"using-jda/interactions/#creating-slash-commands","text":"You can create commands through these methods in JDA: updateCommands() upsertCommand(name, description) Example Java Kotlin guild . updateCommands (). addCommands ( Commands . slash ( \"echo\" , \"Repeats messages back to you.\" ) . addOption ( OptionType . STRING , \"message\" , \"The message to repeat.\" ) . addOption ( OptionType . INTEGER , \"times\" , \"The number of times to repeat the message.\" ) . addOption ( OptionType . BOOLEAN , \"ephemeral\" , \"Whether or not the message should be sent as an ephemeral message.\" ), Commands . slash ( \"animal\" , \"Finds a random animal\" ) . addOptions ( new OptionData ( OptionType . STRING , \"type\" , \"The type of animal to find\" ) . addChoice ( \"Bird\" , \"bird\" ) . addChoice ( \"Big Cat\" , \"bigcat\" ) . addChoice ( \"Canine\" , \"canine\" ) . addChoice ( \"Fish\" , \"fish\" ) ) ). queue (); guild . updateCommands (). addCommands ( Commands . slash ( \"echo\" , \"Repeats messages back to you.\" ) . addOption ( OptionType . STRING , \"message\" , \"The message to repeat.\" ) . addOption ( OptionType . INTEGER , \"times\" , \"The number of times to repeat the message.\" ) . addOption ( OptionType . BOOLEAN , \"ephemeral\" , \"Whether or not the message should be sent as an ephemeral message.\" ), Commands . slash ( \"animal\" , \"Finds a random animal\" ) . addOptions ( OptionData ( OptionType . STRING , \"type\" , \"The type of animal to find\" ) . addChoice ( \"Bird\" , \"bird\" ) . addChoice ( \"Big Cat\" , \"bigcat\" ) . addChoice ( \"Canine\" , \"canine\" ) . addChoice ( \"Fish\" , \"fish\" ) ) ). queue () You need to call these on a JDA instance to create global commands, and on a Guild instance to create guild commands . Your bot needs the applications.commands scope in addition to the bot scope for your bot invite link. Example: https://discord.com/oauth2/authorize?client_id=123456789&scope=bot+applications.commands Warning If the applications.commands scope is not present, JDA will fail to create guild commands, and global commands will not be shown in the client. Once a command is created, it will continue persisting even when your bot restarts. Commands stay until the bot is either kicked or your bot explicitly deletes the command. You don't need to create your commands every time your bot starts!","title":"Creating Slash Commands"},{"location":"using-jda/interactions/#responding-to-slash-commands","text":"When a user tries to use one of your commands you will receive a SlashCommandInteractionEvent . This event needs to be handled by your event listener. The flow of a slash command response is as follows: Acknowledge the command This means you need to either reply or deferReply . You only have 3 SECONDS to acknowledge a command. Since some commands may take longer than 3 seconds you may want to use deferReply to have more time for handling. This will instead send a Thinking... message to channel which is later updated by a followup message (see step 2). Send followup messages Sometimes commands need more than one response. However, you can only send one initial reply to a command. To send additional messages for the same slash command you need to use the InteractionHook attached to the event with getHook() . This is a webhook that allows you to send additional messages for up to 15 minutes after the initial command. When you use deferReply the first message sent to this webhook will act identically to using editOriginal(...) . The message you send is also referred to as deferred reply in this case. Your deferred reply will edit your initial Thinking... message instead of sending an additional message to channel. This means you cannot use setEphemeral on this deferred reply since you already decided whether the message will be ephemeral through your initial acknowledgment. Example Reply Java Kotlin public class SayCommand extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"say\" )) { event . reply ( event . getOption ( \"content\" ). getAsString ()). queue (); // reply immediately } } } object SayCommand : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"say\" ) { event . reply ( event . getOption ( \"content\" ) !! . asString ). queue () } } } Example Deferred Reply Java Kotlin public class TagCommand extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"tag\" )) { event . deferReply (). queue (); // Tell discord we received the command, send a thinking... message to the user String tagName = event . getOption ( \"name\" ). getAsString (); TagDatabase . fingTag ( tagName , ( tag ) -> event . getHook (). sendMessage ( tag ). queue () // delayed response updates our inital \"thinking...\" message with the tag value ); } } } object TagCommand : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"tag\" ) { event . deferReply (). queue () // Tell discord we received the command, send a thinking... message to the user val tagName = event . getOption ( \"name\" ) !! . asString TagDatabase . fingTag ( tagName ) { tag -> event . hook . sendMessage ( tag ). queue () // delayed response updates our inital \"thinking...\" message with the tag value } } } }","title":"Responding to Slash Commands"},{"location":"using-jda/interactions/#managing-slash-command-permissions","text":"Restricting slash commands to specific roles or members is up to the admins of the guild. However, bots can specify a set of permissions that sets who can use those commands by default. Note that members with Permission.ADMINISTRATOR can always use commands, and they can override which roles or members can run the command. JDA only changes the default members and roles that can access it. In order to set this default, .setDefaultPermissions() can be called on the command before you register it. DefaultMemberPermissions.DISABLED can be used to only allow administrators by default, and DefaultMemberPermissions.ENABLED can be used to allow all members by default. Example This will restrict the command so that only members with the Permission.MANAGE_CHANNEL and Permission.MODERATE_MEMBERS permissions can use the command: Java Kotlin guild . updateCommands (). addCommands ( Commands . slash ( \"meeting\" , \"Creates a new channel for an emergency meeting\" ) . setDefaultPermissions ( DefaultMemberPermissions . enabledFor ( Permission . MANAGE_CHANNEL , Permission . MODERATE_MEMBERS )) ). queue (); guild . updateCommands (). addCommands ( Commands . slash ( \"meeting\" , \"Creates a new channel for an emergency meeting\" ) . setDefaultPermissions ( DefaultMemberPermissions . enabledFor ( Permission . MANAGE_CHANNEL , Permission . MODERATE_MEMBERS )) ). queue ()","title":"Managing Slash Command Permissions"},{"location":"using-jda/interactions/#slash-command-autocomplete","text":"Slash command autocompletion is a feature that allows users to begin typing arguments to a command, and suggestions from the bot will be displayed to the user, in-client. Any slash command arguments using the String , Integer or Number types can be autocompleted. By default, options are not autocompleted. In order to make an option autocompleted, OptionData#setAutoComplete(true) may be used.","title":"Slash Command Autocomplete"},{"location":"using-jda/interactions/#handling-autocomplete","text":"As the user is typing an argument that has autocomplete enabled for it, the bot will receive an CommandAutoCompleteInteractionEvent . This event isn't fired for each keystroke, but is sent when Discord determines the user has paused typing for a bit. Autocompletions can suggest up to 25 options, and users do not have to send a command with one of the options. Example Creating the command: Java Kotlin guild . updateCommands (). addCommands ( Commands . slash ( \"fruit\" , \"find a given fruit\" ) . addOption ( OptionType . STRING , \"name\" , \"fruit to find\" , true , true ) ). queue (); guild . updateCommands (). addCommands ( Commands . slash ( \"fruit\" , \"find a given fruit\" ) . addOption ( OptionType . STRING , \"name\" , \"fruit to find\" , required = true , autocomplete = true ) ). queue () Handling the event: Java Kotlin AutoCompleteBot.java public class AutoCompleteBot extends ListenerAdapter { private String [] words = new String [] { \"apple\" , \"apricot\" , \"banana\" , \"cherry\" , \"coconut\" , \"cranberry\" }; @Override public void onCommandAutoCompleteInteraction ( CommandAutoCompleteInteractionEvent event ) { if ( event . getName (). equals ( \"fruit\" ) && event . getFocusedOption (). getName (). equals ( \"name\" )) { List < Command . Choice > options = Stream . of ( words ) . filter ( word -> word . startsWith ( event . getFocusedOption (). getValue ())) // only display words that start with the user's current input . map ( word -> new Command . Choice ( word , word )) // map the words to choices . collect ( Collectors . toList ()); event . replyChoices ( options ). queue (); } } } AutoCompleteBot.kt object AutoCompleteBot : ListenerAdapter () { private val words = arrayOf ( \"apple\" , \"apricot\" , \"banana\" , \"cherry\" , \"coconut\" , \"cranberry\" ) override fun onCommandAutoCompleteInteraction ( event : CommandAutoCompleteInteractionEvent ) { if ( event . name == \"fruit\" && event . focusedOption . name == \"name\" ) { event . replyChoiceStrings ( words . filter { it . startsWith ( event . focusedOption . value ) }). queue () } } }","title":"Handling Autocomplete"},{"location":"using-jda/interactions/#context-menus","text":"Context Menu commands are a special type of command that can be invoked on a user or message by right-clicking on them. These commands take no arguments, and are useful for providing a quick way to perform actions on a user or message. Example Creating the commands: guild . updateCommands (). addCommands ( Commands . context ( Command . Type . USER , \"Get user avatar\" ), Commands . message ( \"Count words\" ) ). queue () Handling the events: Java Kotlin ContextMenuBot.java public class ContextMenuBot extends ListenerAdapter { @Override public void onUserContextInteraction ( UserContextInteractionEvent event ) { if ( event . getName (). equals ( \"Get user avatar\" )) { event . reply ( \"Avatar: \" + event . getTarget (). getEffectiveAvatarUrl ()). queue (); } } @Override public void onMessageContextInteraction ( MessageContextInteractionEvent event ) { if ( event . getName (). equals ( \"Count words\" )) { event . reply ( \"Words: \" + event . getTarget (). getContentRaw (). split ( \"\\\\s+\" ). length ). queue (); } } } ContextMenuBot.kt object ContextMenuBot : ListenerAdapter () { override fun onUserContextInteraction ( event : UserContextInteractionEvent ) { if ( event . name == \"Get user avatar\" ) { event . reply ( \"Avatar: \" + event . target . effectiveAvatarUrl ). queue () } } override fun onMessageContextInteraction ( event : MessageContextInteractionEvent ) { if ( event . name == \"Count words\" ) { event . reply ( \"Words: \" + event . target . contentRaw . split ( Regex ( \"\\\\s+\" )). size ). queue () } } }","title":"Context Menus"},{"location":"using-jda/interactions/#component-interactions","text":"To add components to a message you can use up to 5 ActionRows. You can add multiple ActionRows with either setComponents or addComponents . For the common case of a single ActionRow you can also use setActionRow(Component...) or addActionRow(Component...) . Each ActionRow can hold up to a certain amount of components: 5 Buttons 1 Select Menu (Dropdown) 1 Text Input (Restricted to Modals) These component interactions offer 4 response types: Reply Deferred Reply Edit Message Deferred Edit Message The reply and deferred reply responses are identical to the Slash-Commands response types. However, these new edit response types are used to update the existing message the component is attached to. If you just want to acknowledge that the component was successfully interacted with, you can simply call deferEdit() without any further updates, which will prevent the interaction from failing on the user side. To properly use an interactive component, you need to use the Component ID (aka Custom ID ). This ID can also be used to then identify which component was pressed by the user. Such Component ID is provided by getComponentId() on every Component Interaction. Keep in mind that these Component IDs must be unique across all components in one message .","title":"Component Interactions"},{"location":"using-jda/interactions/#buttons","text":"Each button can be enabled or disabled, have a specific style, label, and emoji:","title":"Buttons"},{"location":"using-jda/interactions/#handling-buttoninteractionevent","text":"When a user presses one of these buttons, you will receive a ButtonInteractionEvent for the respective interaction. Each non-link button requires such an ID in order to be used. Example Java Kotlin public class HelloBot extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"hello\" )) { event . reply ( \"Click the button to say hello\" ) . addActionRow ( Button . primary ( \"hello\" , \"Click Me\" ), // Button with only a label Button . success ( \"emoji\" , Emoji . fromFormatted ( \"<:minn:245267426227388416>\" ))) // Button with only an emoji . queue (); } else if ( event . getName (). equals ( \"info\" )) { event . reply ( \"Click the buttons for more info\" ) . addActionRow ( // link buttons don't send events, they just open a link in the browser when clicked Button . link ( \"https://github.com/DV8FromTheWorld/JDA\" , \"GitHub\" ) . withEmoji ( Emoji . fromFormatted ( \"<:github:849286315580719104>\" )), // Link Button with label and emoji Button . link ( \"https://ci.dv8tion.net/job/JDA/javadoc/\" , \"Javadocs\" )) // Link Button with only a label . queue (); } } @Override public void onButtonInteraction ( ButtonInteractionEvent event ) { if ( event . getComponentId (). equals ( \"hello\" )) { event . reply ( \"Hello :)\" ). queue (); // send a message in the channel } else if ( event . getComponentId (). equals ( \"emoji\" )) { event . editMessage ( \"That button didn't say click me\" ). queue (); // update the message } } } object HelloBot : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"hello\" ) { event . reply ( \"Click the button to say hello\" ) . addActionRow ( Button . primary ( \"hello\" , \"Click Me\" ), // Button with only a label Button . success ( \"emoji\" , Emoji . fromFormatted ( \"<:minn:245267426227388416>\" ))) // Button with only an emoji . queue () } else if ( event . name == \"info\" ) { event . reply ( \"Click the buttons for more info\" ) . addActionRow ( // link buttons don't send events, they just open a link in the browser when clicked Button . link ( \"https://github.com/DV8FromTheWorld/JDA\" , \"GitHub\" ) . withEmoji ( Emoji . fromFormatted ( \"<:github:849286315580719104>\" )), // Link Button with label and emoji Button . link ( \"https://ci.dv8tion.net/job/JDA/javadoc/\" , \"Javadocs\" )) // Link Button with only a label . queue () } } override fun onButtonInteraction ( event : ButtonInteractionEvent ) { when ( event . componentId ) { \"hello\" -> event . reply ( \"Hello :)\" ). queue () // send a message in the channel \"emoji\" -> event . editMessage ( \"That button didn't say click me\" ). queue () // update the message } } }","title":"Handling ButtonInteractionEvent"},{"location":"using-jda/interactions/#select-menus-dropdowns","text":"Select Menus can be disabled. It's possible to set the minimum and maximum number of options to be selected. There are two implementations for SelectMenus: StringSelectMenu supports custom string choices EntitySelectMenu derives its choices from mentionable entities (such as User s, Channel s, etc)","title":"Select Menus (Dropdowns)"},{"location":"using-jda/interactions/#string-select-menus","text":"String Select Menus support up to 25 options. Each option can have its own label, description, and emoji. There can be multiple options selected and set as default.","title":"String Select Menus"},{"location":"using-jda/interactions/#entity-select-menus","text":"Entity Select Menus do not support custom choices. Instead, they derive their choices from mentionable Discord entities such as User s, Channel s, etc. You can specify which entity types you wish to appear as choices by specifying the SelectTarget s in EntitySelectMenu.create . If you create an entity select menu with channel type targets, the same menu may not utilize user or role select targets, and vice versa. You can limit channel selections to specific channel types by using the setChannelTypes method on EntitySelectMenu.Builder . Info These Select Menus do not support setting a custom list of options or customizing the appearance in any way. They always show the complete list of possible entities for the specified types.","title":"Entity Select Menus"},{"location":"using-jda/interactions/#handling-select-menus","text":"When a user selects their options from a dropdown and submits their choices, you will receive either one of the following for the respective interaction: A StringSelectInteractionEvent for a String Select Menu interaction An EntitySelectInteractionEvent for an Entity Select Menu interaction Both interaction events provide the values that were selected by the user. Example String Select Handling Java Kotlin public class StringDropdownBot extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"food\" )) { event . reply ( \"Choose your favorite food\" ) . addActionRow ( StringSelectMenu . create ( \"choose-food\" ) . addOption ( \"Pizza\" , \"pizza\" , \"Classic\" ) // SelectOption with only the label, value, and description . addOptions ( SelectOption . of ( \"Hamburger\" , \"hamburger\" ) // another way to create a SelectOption . withDescription ( \"Tasty\" ) // this time with a description . withEmoji ( Emoji . fromUnicode ( \"\\uD83C\\uDF54\" )) // and an emoji . withDefault ( true )) // while also being the default option . build ()) . queue (); } } @Override public void onStringSelectInteraction ( StringSelectInteractionEvent event ) { if ( event . getComponentId (). equals ( \"choose-food\" )) { event . reply ( \"You chose \" + event . getValues (). get ( 0 )). queue (); } } } object StringDropdownBot : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"food\" ) { val selectMenu = StringSelectMenu . create ( \"choose-food\" ) . addOption ( \"Pizza\" , \"pizza\" , \"Classic\" ) // SelectOption with only the label, value, and description . addOptions ( SelectOption . of ( \"Hamburger\" , \"hamburger\" ) // another way to create a SelectOption . withDescription ( \"Tasty\" ) // this time with a description . withEmoji ( Emoji . fromUnicode ( \"\\uD83C\\uDF54\" )) // and an emoji . withDefault ( true )) // while also being the default option . build () event . reply ( \"Choose your favorite food\" ) . addActionRow ( selectMenu ) . queue () } } override fun onStringSelectInteraction ( event : StringSelectInteractionEvent ) { if ( event . componentId == \"choose-food\" ) { event . reply ( \"You chose \" + event . values [ 0 ] ). queue () } } } Example Entity Select Handling Java Kotlin public class EntityDropdownBot extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"highfive\" )) { event . reply ( \"Choose the user to high-five\" ) . addActionRow ( EntitySelectMenu . create ( \"choose-user\" , SelectTarget . USER ) . build ()) . queue (); } } @Override public void onEntitySelectInteraction ( EntitySelectInteractionEvent event ) { if ( event . getComponentId (). equals ( \"choose-user\" )) { // Mentions provide the selected values using familiar getters List < User > users = event . getMentions (). getUsers (); event . reply ( \"You high-fived \" + users . get ( 0 ). getAsMention ()). queue (); } } } object EntityDropdownBot : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"food\" ) { val selectMenu = EntitySelectMenu . create ( \"choose-user\" , SelectTarget . USER ) . build () event . reply ( \"Choose the user to high-five\" ) . addActionRow ( selectMenu ) . queue () } } override fun onEntitySelectInteraction ( event : EntitySelectInteractionEvent ) { if ( event . componentId == \"choose-user\" ) { // Mentions provide the selected values using familiar getters val users = event . mentions . users ; event . reply ( \"You high-fived \" + users . first (). asMention ). queue () } } }","title":"Handling Select Menus"},{"location":"using-jda/interactions/#modals","text":"Modals are pop-ups that appear in a user's Discord client. Similarly to messages, Modals can contain up to 5 ActionRows, although the only component that can be put inside Modals at the moment ( TextInput ) takes up a whole ActionRow.","title":"Modals"},{"location":"using-jda/interactions/#replying-with-a-modal","text":"Example Java Kotlin public class SupportCommand extends ListenerAdapter { @Override public void onSlashCommandInteraction ( SlashCommandInteractionEvent event ) { if ( event . getName (). equals ( \"modmail\" )) { TextInput subject = TextInput . create ( \"subject\" , \"Subject\" , TextInputStyle . SHORT ) . setPlaceholder ( \"Subject of this ticket\" ) . setMinLength ( 10 ) . setMaxLength ( 100 ) // or setRequiredRange(10, 100) . build (); TextInput body = TextInput . create ( \"body\" , \"Body\" , TextInputStyle . PARAGRAPH ) . setPlaceholder ( \"Your concerns go here\" ) . setMinLength ( 30 ) . setMaxLength ( 1000 ) . build (); Modal modal = Modal . create ( \"modmail\" , \"Modmail\" ) . addComponents ( ActionRow . of ( subject ), ActionRow . of ( body )) . build (); event . replyModal ( modal ). queue (); } } } object SupportCommand : ListenerAdapter () { override fun onSlashCommandInteraction ( event : SlashCommandInteractionEvent ) { if ( event . name == \"modmail\" ) { val subject = TextInput . create ( \"subject\" , \"Subject\" , TextInputStyle . SHORT ) . setPlaceholder ( \"Subject of this ticket\" ) . setMinLength ( 10 ) . setMaxLength ( 100 ) // or setRequiredRange(10, 100) . build () val body = TextInput . create ( \"body\" , \"Body\" , TextInputStyle . PARAGRAPH ) . setPlaceholder ( \"Your concerns go here\" ) . setMinLength ( 30 ) . setMaxLength ( 1000 ) . build () val modal = Modal . create ( \"modmail\" , \"Modmail\" ) . addComponents ( ActionRow . of ( subject ), ActionRow . of ( body )) . build () event . replyModal ( modal ). queue () } } }","title":"Replying with a Modal"},{"location":"using-jda/interactions/#handling-modalinteractionevent","text":"When the user clicks the \"Submit\" button on the Modal, you will receive an ModalInteractionEvent , containing all the values the user put in it. Warning Acknowledging a ModalInteractionEvent is necessary. Failing to respond to the event will not close it on the user's client, and will show them an error. Info If the Modal originated from a Component-Interaction (Buttons, SelectMenus), it is possible to acknowledge the interaction using an edit to the original Message using editMessage() or similar. Example Java Kotlin public class ModalListener extends ListenerAdapter { @Override public void onModalInteraction ( @Nonnull ModalInteractionEvent event ) { if ( event . getModalId (). equals ( \"modmail\" )) { String subject = event . getValue ( \"subject\" ). getAsString (); String body = event . getValue ( \"body\" ). getAsString (); createSupportTicket ( subject , body ); event . reply ( \"Thanks for your request!\" ). setEphemeral ( true ). queue (); } } } object ModalListener : ListenerAdapter () { override fun onModalInteraction ( event : ModalInteractionEvent ) { if ( event . modalId == \"modmail\" ) { val subject = event . getValue ( \"subject\" ) ?: return val body = event . getValue ( \"body\" ) ?: return createSupportTicket ( subject , body ) event . reply ( \"Thanks for your request!\" ). setEphemeral ( true ). queue () } } }","title":"Handling ModalInteractionEvent"},{"location":"using-jda/making-a-music-bot/","text":"What do I need to get started? \u00b6 Set up your project: IntelliJ IDEA Eclipse Netbeans Set up JDA Once you have your project you will need an additional dependency for your AudioSendHandler If you don't want to implement it yourself, use LavaPlayer Connecting to a VoiceChannel \u00b6 Getting a VoiceChannel ( guild references an instance of Guild ) By the channel id: guild.getVoiceChannelById(CHANNEL_ID) VoiceChannel myChannel = guild.getVoiceChannelById(CHANNEL_ID); By the channel name: guild.getVoiceChannelsByName(CHANNEL_NAME, true) VoiceChannel myChannel = guild.getVoiceChannelsByName(CHANNEL_NAME, true).get(0); By the voice state of a member member.getVoiceState().getChannel() VoiceChannel myChannel = member.getVoiceState().getChannel(); Retrieve the AudioManager AudioManager audioManager = guild.getAudioManager(); Open an audio connection audioManager.openAudioConnection() audioManager.openAudioConnection(myChannel); Note It may be important to do certain permission checks before trying to open an audio connection! It may result in a PermissionException throw otherwise! Sending Audio to an Open Audio Connection \u00b6 Note For LavaPlayer read here Retrieve the AudioManager AudioManager audioManager = guild.getAudioManager(); Create a new AudioSendHandler instance for your implementation. Register your AudioSendHandler: audioManager.setSendingHandler(myAudioSendHandler) You may only use one AudioSendHandler per Guild and not use the same instance on another Guild! Doing that will result in speedup due to multiple send threads pulling from the same instance! A Working Example \u00b6 public class MusicBot extends ListenerAdapter { public static void main ( String [] args ) throws IllegalArgumentException , LoginException , RateLimitedException { JDABuilder . createDefault ( args [ 0 ] ) // Use token provided as JVM argument . addEventListeners ( new MusicBot ()) // Register new MusicBot instance as EventListener . build (); // Build JDA - connect to discord } @Override public void onMessageReceived ( MessageReceivedEvent event ) { // Make sure we only respond to events that occur in a guild if ( ! event . isFromGuild ()) return ; // This makes sure we only execute our code when someone sends a message with \"!play\" if ( ! event . getMessage (). getContentRaw (). startsWith ( \"!play\" )) return ; // Now we want to exclude messages from bots since we want to avoid command loops in chat! // this will include own messages as well for bot accounts // if this is not a bot make sure to check if this message is sent by yourself! if ( event . getAuthor (). isBot ()) return ; Guild guild = event . getGuild (); // This will get the first voice channel with the name \"music\" // matching by voiceChannel.getName().equalsIgnoreCase(\"music\") VoiceChannel channel = guild . getVoiceChannelsByName ( \"music\" , true ). get ( 0 ); AudioManager manager = guild . getAudioManager (); // MySendHandler should be your AudioSendHandler implementation manager . setSendingHandler ( new MySendHandler ()); // Here we finally connect to the target voice channel // and it will automatically start pulling the audio from the MySendHandler instance manager . openAudioConnection ( channel ); } } Important This example expects you to have your own AudioSendHandler implementation. It is crucial you only use one AudioSendHandler per Guild! Using LavaPlayer \u00b6 Set up LavaPlayer Implement an AudioSendHandler Example Connect to a voice channel Register your AudioSendHandler Use the LavaPlayer resources: How To Use LavaPlayer More example implementations can be found in existing bots like: \u00b6 AudioEchoExample Source Clarity by @jagrosh GitHub Wiki FredBoat by @freyacodes GitHub relevant package","title":"Making a Music Bot"},{"location":"using-jda/making-a-music-bot/#what-do-i-need-to-get-started","text":"Set up your project: IntelliJ IDEA Eclipse Netbeans Set up JDA Once you have your project you will need an additional dependency for your AudioSendHandler If you don't want to implement it yourself, use LavaPlayer","title":"What do I need to get started?"},{"location":"using-jda/making-a-music-bot/#connecting-to-a-voicechannel","text":"Getting a VoiceChannel ( guild references an instance of Guild ) By the channel id: guild.getVoiceChannelById(CHANNEL_ID) VoiceChannel myChannel = guild.getVoiceChannelById(CHANNEL_ID); By the channel name: guild.getVoiceChannelsByName(CHANNEL_NAME, true) VoiceChannel myChannel = guild.getVoiceChannelsByName(CHANNEL_NAME, true).get(0); By the voice state of a member member.getVoiceState().getChannel() VoiceChannel myChannel = member.getVoiceState().getChannel(); Retrieve the AudioManager AudioManager audioManager = guild.getAudioManager(); Open an audio connection audioManager.openAudioConnection() audioManager.openAudioConnection(myChannel); Note It may be important to do certain permission checks before trying to open an audio connection! It may result in a PermissionException throw otherwise!","title":"Connecting to a VoiceChannel"},{"location":"using-jda/making-a-music-bot/#sending-audio-to-an-open-audio-connection","text":"Note For LavaPlayer read here Retrieve the AudioManager AudioManager audioManager = guild.getAudioManager(); Create a new AudioSendHandler instance for your implementation. Register your AudioSendHandler: audioManager.setSendingHandler(myAudioSendHandler) You may only use one AudioSendHandler per Guild and not use the same instance on another Guild! Doing that will result in speedup due to multiple send threads pulling from the same instance!","title":"Sending Audio to an Open Audio Connection"},{"location":"using-jda/making-a-music-bot/#a-working-example","text":"public class MusicBot extends ListenerAdapter { public static void main ( String [] args ) throws IllegalArgumentException , LoginException , RateLimitedException { JDABuilder . createDefault ( args [ 0 ] ) // Use token provided as JVM argument . addEventListeners ( new MusicBot ()) // Register new MusicBot instance as EventListener . build (); // Build JDA - connect to discord } @Override public void onMessageReceived ( MessageReceivedEvent event ) { // Make sure we only respond to events that occur in a guild if ( ! event . isFromGuild ()) return ; // This makes sure we only execute our code when someone sends a message with \"!play\" if ( ! event . getMessage (). getContentRaw (). startsWith ( \"!play\" )) return ; // Now we want to exclude messages from bots since we want to avoid command loops in chat! // this will include own messages as well for bot accounts // if this is not a bot make sure to check if this message is sent by yourself! if ( event . getAuthor (). isBot ()) return ; Guild guild = event . getGuild (); // This will get the first voice channel with the name \"music\" // matching by voiceChannel.getName().equalsIgnoreCase(\"music\") VoiceChannel channel = guild . getVoiceChannelsByName ( \"music\" , true ). get ( 0 ); AudioManager manager = guild . getAudioManager (); // MySendHandler should be your AudioSendHandler implementation manager . setSendingHandler ( new MySendHandler ()); // Here we finally connect to the target voice channel // and it will automatically start pulling the audio from the MySendHandler instance manager . openAudioConnection ( channel ); } } Important This example expects you to have your own AudioSendHandler implementation. It is crucial you only use one AudioSendHandler per Guild!","title":"A Working Example"},{"location":"using-jda/making-a-music-bot/#using-lavaplayer","text":"Set up LavaPlayer Implement an AudioSendHandler Example Connect to a voice channel Register your AudioSendHandler Use the LavaPlayer resources: How To Use LavaPlayer","title":"Using LavaPlayer"},{"location":"using-jda/making-a-music-bot/#more-example-implementations-can-be-found-in-existing-bots-like","text":"AudioEchoExample Source Clarity by @jagrosh GitHub Wiki FredBoat by @freyacodes GitHub relevant package","title":"More example implementations can be found in existing bots like:"},{"location":"using-jda/paginating-entities/","text":"PaginationAction \u00b6 In some scenarios the Discord API allows to paginate endpoints to retrieve entities in bulks. Such an endpoint is especially often used for retrieving past messages in the client by scrolling up. In JDA we allow iterating such endpoints with the Iterable PaginationAction implementations. Using it inside an enhanced for-loop is a blocking and expensive operation so it is recommended to use the async methods instead. Example Messages /** * Retrieves up to 1000 messages from the provided MessageChannel * and then provides them to the callback. */ public void get1000 ( MessageChannel channel , Consumer < List < Message >> callback ) { List < Message > messages = new ArrayList <> ( 1000 ); channel . getIterableHistory (). cache ( false ). forEachAsync (( message ) -> { messages . add ( message ); return messages . size () < 1000 ; }). thenRun (() -> callback . accept ( messages )); } get1000 ( channel , ( messages ) -> channel . purgeMessages ( messages )); Entity Cache \u00b6 Note PaginationActions support the Stream api which was introduced in Java 1.8. Stream requires blocking operations and can take long to finish. Every PaginationAction has a cache of already retrieved entities. This cache is enabled by default but can be disabled via PaginationAction.cache(false) . Doing so is recommended if the cache is not needed. To retrieve all cached entities use PaginationAction.getCached() . This returns an immutable List representing all cached entities (thread-safe but expanding). You may also get the first/last entity with getLast() and getFirst() for convenience. By default the PaginationAction will retrieve the maximum amount of entities per request (complete/queue). It is advised to lower this limit if only a small number of entities is required. (See limit(int) ). Usage examples public class PaginationUtil { // Calls the callback if the user has reacted public static void ifReacted ( MessageReaction reaction , User user , Runnable callback ) { reaction . getUsers (). cache ( false ). forEachAsync ( u -> { if ( u . equals ( user )) { callback . run (); // user has reacted -> call the callback return false ; // end iteration } return true ; // continue iteration }); } // Blocking iteration using the Iterable interface (not recommended) public static List < Message > forEachMessage ( int limit , MessageChannel channel , Consumer < Message > action ) { MessagePaginationAction paginator = channel . getIterableHistory (); for ( Message message : paginator ) { action . apply ( message ); if ( -- limit <= 0 ) break ; } return paginator . getCached (); } }","title":"Paginating Entities"},{"location":"using-jda/paginating-entities/#paginationaction","text":"In some scenarios the Discord API allows to paginate endpoints to retrieve entities in bulks. Such an endpoint is especially often used for retrieving past messages in the client by scrolling up. In JDA we allow iterating such endpoints with the Iterable PaginationAction implementations. Using it inside an enhanced for-loop is a blocking and expensive operation so it is recommended to use the async methods instead. Example Messages /** * Retrieves up to 1000 messages from the provided MessageChannel * and then provides them to the callback. */ public void get1000 ( MessageChannel channel , Consumer < List < Message >> callback ) { List < Message > messages = new ArrayList <> ( 1000 ); channel . getIterableHistory (). cache ( false ). forEachAsync (( message ) -> { messages . add ( message ); return messages . size () < 1000 ; }). thenRun (() -> callback . accept ( messages )); } get1000 ( channel , ( messages ) -> channel . purgeMessages ( messages ));","title":"PaginationAction"},{"location":"using-jda/paginating-entities/#entity-cache","text":"Note PaginationActions support the Stream api which was introduced in Java 1.8. Stream requires blocking operations and can take long to finish. Every PaginationAction has a cache of already retrieved entities. This cache is enabled by default but can be disabled via PaginationAction.cache(false) . Doing so is recommended if the cache is not needed. To retrieve all cached entities use PaginationAction.getCached() . This returns an immutable List representing all cached entities (thread-safe but expanding). You may also get the first/last entity with getLast() and getFirst() for convenience. By default the PaginationAction will retrieve the maximum amount of entities per request (complete/queue). It is advised to lower this limit if only a small number of entities is required. (See limit(int) ). Usage examples public class PaginationUtil { // Calls the callback if the user has reacted public static void ifReacted ( MessageReaction reaction , User user , Runnable callback ) { reaction . getUsers (). cache ( false ). forEachAsync ( u -> { if ( u . equals ( user )) { callback . run (); // user has reacted -> call the callback return false ; // end iteration } return true ; // continue iteration }); } // Blocking iteration using the Iterable interface (not recommended) public static List < Message > forEachMessage ( int limit , MessageChannel channel , Consumer < Message > action ) { MessagePaginationAction paginator = channel . getIterableHistory (); for ( Message message : paginator ) { action . apply ( message ); if ( -- limit <= 0 ) break ; } return paginator . getCached (); } }","title":"Entity Cache"},{"location":"using-jda/separation-of-concerns/","text":"Separation of Concerns \u00b6 In JDA we follow the pattern of Separation of Concerns (SoC) for our entities. This means that updates and moderation all happens in dedicated classes rather than on the entities themselves (with a few exceptions like deletion) Each entity that can be updated directly has a Manager instance which can be used to update one or more of the entity properties such as its name. Managers \u00b6 The managers in JDA are useful to update entities. Without many complications, you can update many of properties in a single RestAction execution (HTTP request). Updating an Entity \u00b6 We will make a small example here on how to update the name and the topic of a TextChannel . public void updateChannel ( TextChannel channel ) { ChannelManager manager = channel . getManager (); // get the manager manager . setName ( \"testing-2\" ). setTopic ( \"This is a testing channel, no memes allowed\" ); // set the new values manager . queue (); // execute update, this updates both name and topic } Note queue() is async so the update is not done when this method returns! Re-usability of Managers \u00b6 Every manager in JDA is cached for re-use and can be updated for an interval and then executed upon command, very useful for bots! Example State Machine import net.dv8tion.jda.api.events.message.MessageReceivedEvent ; import net.dv8tion.jda.api.hooks.ListenerAdapter ; import net.dv8tion.jda.api.entities.* ; import net.dv8tion.jda.api.MessageBuilder ; import net.dv8tion.jda.api.requests.restaction.MessageAction ; // derived with permission from https://gist.github.com/MinnDevelopment/190b79109b17c3bb446eea13be57c43c public class UpdateStateMachine extends ListenerAdapter { private final TextChannel channel ; private String name = null ; private String topic = null ; private int state = 0 ; public UpdateStateMachine ( TextChannel channel ) { this . channel = channel ; } @Override public void onMessageReceived ( MessageReceivedEvent event ) { if ( ! event . isFromGuild ()) return ; if ( ! event . getChannel (). equals ( channel )) return ; String content = event . getMessage (). getContentRaw (); if ( ! content . startsWith ( \"!update \" )) return ; String parts [] = content . split ( \" \" , 2 ); String arguments = parts . length > 1 ? parts [ 1 ] : \"\" ; switch ( state ) { case 0 : // setting mode if ( arguments . equals ( \"done\" )) { // finish update state = 2 ; // enter update mode sendStatus (). append ( \"\\nType `!update yes` to finish!\" ). queue (); } else if ( arguments . equals ( \"reset\" )) { // reset state state = 1 ; // enter reset mode sendStatus (). append ( \"\\nType `!update yes` to reset!\" ). queue (); } else if ( arguments . startsWith ( \"topic \" )) { // update topic this . topic = arguments . split ( \" \" , 2 ) [ 1 ] ; channel . getManager (). setTopic ( this . topic ); } else if ( arguments . startsWith ( \"name \" )) { // update name this . name = arguments . split ( \" \" , 3 ) [ 1 ] ; channel . getManager (). setName ( this . name ); } else { channel . sendMessage ( \"I'm sorry I did not understand.\" ). queue (); } break ; case 1 : // reset mode state = 0 ; if ( arguments . equals ( \"yes\" )) // we should reset resetState (); else // nevermind, we are not done channel . sendMessage ( \"Ok, what do you want to change?\" ). queue (); break ; case 2 : // update mode state = 0 ; if ( arguments . equals ( \"yes\" )) // we should update channel . getManager (). queue (( v ) -> resetState ()); else // nevermind, we are not done channel . sendMessage ( \"Ok, what do you want to change?\" ). queue (); break ; } } protected void resetState () { channel . getManager (). reset (); this . name = null ; this . topic = null ; } private MessageAction sendStatus () { MessageBuilder builder = new MessageBuilder (); builder . append ( \"**Current Status**\" ); if ( name != null || topic != null ) { StringBuilder changes = new StringBuilder (); if ( name != null ) changes . append ( \"name -> \" ). append ( name ). append ( \"\\n\" ); if ( topic != null ) changes . append ( \"topic -> \" ). append ( topic ); builder . appendCodeBlock ( changes , \"\" ); } return builder . sendTo ( channel ); } } Exceptions to SoC Pattern \u00b6 The only exceptions we have are deletion and creation. All entities are deleted directly using its delete() method, for instance Channel.delete() . You can create copies of entities in the same fashion with one twist. Some createCopy() methods allow you to modify the new copy before execution of the RestAction Note This will copy the provided Channel and set its name to the provided newName ! public void copyChannel ( Channel channel , String newName ) { channel . createCopy (). setName ( newName ). queue (); } These things can be overlooked, so we do recommend inspecting the return type of these operations: getManager() , create...() , delete() , ban(...) , kick(...) and similar when you use them so that you are not caught out.","title":"Managers and Moderation"},{"location":"using-jda/separation-of-concerns/#separation-of-concerns","text":"In JDA we follow the pattern of Separation of Concerns (SoC) for our entities. This means that updates and moderation all happens in dedicated classes rather than on the entities themselves (with a few exceptions like deletion) Each entity that can be updated directly has a Manager instance which can be used to update one or more of the entity properties such as its name.","title":"Separation of Concerns"},{"location":"using-jda/separation-of-concerns/#managers","text":"The managers in JDA are useful to update entities. Without many complications, you can update many of properties in a single RestAction execution (HTTP request).","title":"Managers"},{"location":"using-jda/separation-of-concerns/#updating-an-entity","text":"We will make a small example here on how to update the name and the topic of a TextChannel . public void updateChannel ( TextChannel channel ) { ChannelManager manager = channel . getManager (); // get the manager manager . setName ( \"testing-2\" ). setTopic ( \"This is a testing channel, no memes allowed\" ); // set the new values manager . queue (); // execute update, this updates both name and topic } Note queue() is async so the update is not done when this method returns!","title":"Updating an Entity"},{"location":"using-jda/separation-of-concerns/#re-usability-of-managers","text":"Every manager in JDA is cached for re-use and can be updated for an interval and then executed upon command, very useful for bots! Example State Machine import net.dv8tion.jda.api.events.message.MessageReceivedEvent ; import net.dv8tion.jda.api.hooks.ListenerAdapter ; import net.dv8tion.jda.api.entities.* ; import net.dv8tion.jda.api.MessageBuilder ; import net.dv8tion.jda.api.requests.restaction.MessageAction ; // derived with permission from https://gist.github.com/MinnDevelopment/190b79109b17c3bb446eea13be57c43c public class UpdateStateMachine extends ListenerAdapter { private final TextChannel channel ; private String name = null ; private String topic = null ; private int state = 0 ; public UpdateStateMachine ( TextChannel channel ) { this . channel = channel ; } @Override public void onMessageReceived ( MessageReceivedEvent event ) { if ( ! event . isFromGuild ()) return ; if ( ! event . getChannel (). equals ( channel )) return ; String content = event . getMessage (). getContentRaw (); if ( ! content . startsWith ( \"!update \" )) return ; String parts [] = content . split ( \" \" , 2 ); String arguments = parts . length > 1 ? parts [ 1 ] : \"\" ; switch ( state ) { case 0 : // setting mode if ( arguments . equals ( \"done\" )) { // finish update state = 2 ; // enter update mode sendStatus (). append ( \"\\nType `!update yes` to finish!\" ). queue (); } else if ( arguments . equals ( \"reset\" )) { // reset state state = 1 ; // enter reset mode sendStatus (). append ( \"\\nType `!update yes` to reset!\" ). queue (); } else if ( arguments . startsWith ( \"topic \" )) { // update topic this . topic = arguments . split ( \" \" , 2 ) [ 1 ] ; channel . getManager (). setTopic ( this . topic ); } else if ( arguments . startsWith ( \"name \" )) { // update name this . name = arguments . split ( \" \" , 3 ) [ 1 ] ; channel . getManager (). setName ( this . name ); } else { channel . sendMessage ( \"I'm sorry I did not understand.\" ). queue (); } break ; case 1 : // reset mode state = 0 ; if ( arguments . equals ( \"yes\" )) // we should reset resetState (); else // nevermind, we are not done channel . sendMessage ( \"Ok, what do you want to change?\" ). queue (); break ; case 2 : // update mode state = 0 ; if ( arguments . equals ( \"yes\" )) // we should update channel . getManager (). queue (( v ) -> resetState ()); else // nevermind, we are not done channel . sendMessage ( \"Ok, what do you want to change?\" ). queue (); break ; } } protected void resetState () { channel . getManager (). reset (); this . name = null ; this . topic = null ; } private MessageAction sendStatus () { MessageBuilder builder = new MessageBuilder (); builder . append ( \"**Current Status**\" ); if ( name != null || topic != null ) { StringBuilder changes = new StringBuilder (); if ( name != null ) changes . append ( \"name -> \" ). append ( name ). append ( \"\\n\" ); if ( topic != null ) changes . append ( \"topic -> \" ). append ( topic ); builder . appendCodeBlock ( changes , \"\" ); } return builder . sendTo ( channel ); } }","title":"Re-usability of Managers"},{"location":"using-jda/separation-of-concerns/#exceptions-to-soc-pattern","text":"The only exceptions we have are deletion and creation. All entities are deleted directly using its delete() method, for instance Channel.delete() . You can create copies of entities in the same fashion with one twist. Some createCopy() methods allow you to modify the new copy before execution of the RestAction Note This will copy the provided Channel and set its name to the provided newName ! public void copyChannel ( Channel channel , String newName ) { channel . createCopy (). setName ( newName ). queue (); } These things can be overlooked, so we do recommend inspecting the return type of these operations: getManager() , create...() , delete() , ban(...) , kick(...) and similar when you use them so that you are not caught out.","title":"Exceptions to SoC Pattern"},{"location":"using-jda/troubleshooting/","text":"Troubleshooting \u00b6 This is a collection of common issues and recommended solutions. Didn't find an answer? Try asking in our Discord server Shutdown but the process doesn't exit \u00b6 When you call JDA.shutdown() or JDA.shutdownNow() the JDA instance will stop all of its threads. However, if HTTP/2 was used by the OkHttpClient instance it will keep the JVM running due to a timeout thread for http connections. This can be terminated by shutting it down manually: OkHttpClient client = jda . getHttpClient (); client . connectionPool (). evictAll (); client . dispatcher (). executorService (). shutdown (); NoClassDefFoundError or ClassNotFoundException on startup \u00b6 An error like java.lang.NoClassDefFoundError: net/dv8tion/jda/api/JDABuilder or similar means you are not including your dependencies or transitive dependencies in the archive. Gradle (build.gradle) Maven (pom.xml) Jar With Gradle this can be fixed by using the shadow plugin and building your jar with shadowJar instead. The jar will then be present in the build/libs directory with a name like example-1.0-all.jar With Maven you need the shade plugin in your pom to add dependencies to your package task. You can see the shade plugin being applied in this example pom.xml You need to use the -withDependencies.jar rather than the normal one. Discord Issues and API Limitations \u00b6 The provided token is invalid! \u00b6 javax.security.auth.login.LoginException: The provided token is invalid! This exception indicates that the token you have used in your JDABuilder is not a valid bot token. Usually, this means you tried using the secret instead of the bot token. To get your token, follow these steps: Open the Application Dashboard Select your application On the left side, click the Bot tab If you don't have a bot yet, you must create one Once you have a bot, there is a token section. Click COPY . The token is now in your clipboard and you can paste it into your code If you follow these steps and you still get the same exception, it could be due to one of these problems: You included excess whitespace in your string. The token string should not include any newlines or spaces. You were banned from the API or your server is hosted on a public hosting platform like Glitch or Heroku. The token is not for a bot account, we do not support client accounts. A valid token looks like this: NDkyNzQ3NzY5MDM2MDEzNTc4.Xw2cUA.LLslVBE1tfFK20sGsNm-FVFYdsA Caution NEVER SHARE YOUR TOKEN WITH ANYONE. DO NOT COMMIT IT AND PUSH IT TO GITHUB. DO NOT SHOW IT TO ANYONE UNDER ANY CIRCUMSTANCES. Can't get emoji from message \u00b6 Methods such as Mentions.getCustomEmojis() and Mentions.getCustomEmojisBag() only include custom emoji which have to be uploaded to a guild by a moderator. Unicode emoji such as \ud83d\udc4d are not included and require using a 3rd party library to be located in a string. You can use emoji-java to extract unicode emoji from a message. An example use-case including a code sample can be found in this answer to a related question on StackOverflow Event Handling and RestActions \u00b6 RestAction queue returned failure \u00b6 When JDA encounters an issue while executing a RestAction it will emit an error through the failure callback . You can handle this by adding a second callback to queue() , for example: message.delete().queue(v -> System.out.println(\"success\"), ContextException.herePrintingTrace\u200b()); . Example public void deleteMessage ( Message message ) { message . delete (). queue ( null , ( exception ) -> { message . getChannel (). sendMessage ( \"There was an error \" + exception ). queue (); }); } You can use ErrorHandler to handle or ignore specific ErrorResponse failures. Nothing happens when using X \u00b6 In JDA we make use of async rate-limit handling through the use of the common RestAction class. When you have code such as channel.sendMessage(\"hello\"); or message.delete(); nothing actually happens. This is because both sendMessage(...) as well as delete() return a RestAction instance. You are not done here since that class is only an intermediate step to executing your request. Here you can decide to use async queue() (recommended) or submit() or the blocking complete() (not recommended). You might notice that queue() returns void . This is because it's async and uses callbacks instead. Read More If you do have a queue() then maybe your code doesn't even run? Try putting a System.out.println(\"debug\") right before and after your code and see if it prints. If not, then read this My event listener code is not executed . My event listener code is not executed \u00b6 There are many reasons why your event listener might not be executed but here are the most common issues: You are using a deprecated or removed part of JDA, such as new JDABuilder(...) . Use the replacement that is documented, for example createDefault(token) . You are using the wrong login token. If the token is for another bot which doesn't have access to the desired guilds then the event listener code cannot run. Your bot is not actually in the guild. Make sure your bot is online and has access to the resource you are trying to interact with. You never registered your listener. Use jda.addEventListener(new MyListener()) on either the JDABuilder or JDA instance You did not override the correct method. Use @Override and see if it fails. Your method has to use the correct name and parameter list defined in ListenerAdapter . Read More . You don't actually extend EventListener or ListenerAdapter . Your class should either use extends ListenerAdapter or implements EventListener . You are missing a required GatewayIntent for this event. Make sure that you enableIntents(...) on the JDABuilder to allow the events to be received. The event has other requirements that might not be satisfied such as the cache not being enabled. Please check the requirements on the event documentation. If none of the above apply to you then you might have an issue in your listener's code, at that point you should use a debugger. Missed 2 heartbeats! Trying to reconnect... \u00b6 This warning implies your event thread is too busy and will block critical events from being received. You should try to limit blocking calls and make sure your event handlers don't take up too much time. Do profiling to figure out what takes so long or create a thread dump when you get this warning to see where the issue is. By default, all events are handled on the same thread they get received and handled on. If you block this thread for too long then JDA cannot keep up with important lifecycle events sent by Discord. Either you start writing non-blocking code (replace complete() with queue() etc.) or you use a thread pool for your event handling. Listener must implement EventListener \u00b6 Exception in thread \"main\" java.lang.IllegalArgumentException: Listener must implement EventListener at net.dv8tion.jda.api.hooks.InterfacedEventManager.register(InterfacedEventManager.java:62) at net.dv8tion.jda.internal.hooks.EventManagerProxy.register(EventManagerProxy.java:52) at net.dv8tion.jda.internal.JDAImpl.addEventListener(JDAImpl.java:810) at net.dv8tion.jda.api.JDABuilder.lambda$build$0(JDABuilder.java:1841) at java.base/java.lang.Iterable.forEach(Iterable.java:75) at net.dv8tion.jda.api.JDABuilder.build(JDABuilder.java:1841) When you get an exception like this, that means one of the event listeners you registered does not implement the EventListener interface provided by JDA. This is not a valid event listener class: public class MyListener { ... } You can either use ListenerAdapter or EventListener : import net.dv8tion.jda.api.hooks.ListenerAdapter ; public class MyListener extends ListenerAdapter { ... } When using EventListner make sure you actually imported the correct interface from JDA and not java.util.EventListner : import net.dv8tion.jda.api.events.GenericEvent ; import net.dv8tion.jda.api.hooks.EventListener ; public class MyListener extends EventListener { @Override public void onEvent ( GenericEvent event ) { ... } } Read More I can't get the previous message content from delete/update \u00b6 When Discord emits a message_delete or message_update they only provide the new content of the message. Since JDA does not keep a cache of messages it is unable to provide the previous content. Instead you will have to track content of messages yourself. Preventing use of complete() in callback threads \u00b6 The following code will illustrate an issue where callbacks might cause a deadlock class Main { public static main ( String [] args ) { JDA api = JDABuilder . createDefault ( BOT_TOKEN ) . setCallbackPool ( Executors . newSingleThreadScheduledExecutor ()) // (1) . build (). awaitReady (); TextChannel channel = api . getTextChannelById ( CHANNEL_ID ); channel . sendMessage ( \"hello there\" ). queue (( message ) -> { // (2) System . out . println ( \"Hello\" ); message . editMessage ( \"general kenobi\" ). complete (); // (3) deadlock System . out . println ( \"World!!!!\" ); // never printed }); } } You can test this yourself on 3.8.0 and see it fail. Since we decided to use a single-thread pool (1) we only have one thread to execute callbacks. This thread is used by the first callback (2) and cannot be used for the second callback (3). Due to this reason we simply don't allow using complete() in any callback threads at all. If you use callbacks you should use queue() . RateLimits \u00b6 Hit the WebSocket RateLimit \u00b6 When you update your game or online status you emit a socket message to Discord. If you do that often enough you hit a limit and JDA has to backoff for 60 seconds. Things that contribute to the WebSocket RateLimit include: AudioManager.openAudioConnection(...) AudioManager.closeAudioConnection() AudioManager.setSelfMuted(...) AudioManager.setSelfDeafened(...) Any setter method on Presence . It is also possible that you get spammed by this warning if you use ChunkingFilter.ALL (this is done when using create(token, intents) ). If your bot is in more than 120 guilds then this warning is unavoidable when using member chunking. It is recommended to use setChunkingFilter(ChunkingFilter.NONE) to reduce the startup time and get rid of this warning. If chunking on startup is absolutely necessary, you have to accept this warning. There are many ways to retrieve members: Loading Members I explained this in a bit more detail in issue #1290 To make chunking a little more efficient, you can additionally enable the GatewayIntent.GUILD_PRESENCES . This will load all online members for each guild directly, instead of relying on additional member chunk requests, which can be a significant boost to reduce startup time and potentially reduce these warnings. Encountered 429 or Encountered global rate limit \u00b6 When the internal jda rate-limiter fails to predict a rate limit bucket the HTTP response is 429: TOO MANY REQUESTS . This means the request has to be retried. If you see this a lot (many times per minute), then JDA might have an issue with the rate limit handling of that route. If you use setRelativeRateLimit(false) it could also mean that your clock is not properly synchronizing with NTP. Encountering the global rate-limit is something JDA cannot predict or prevent. This rate-limit implies you sent too many requests in total across all routes. Discord limits how much HTTP traffic a client is allowed to do and will tell us to limit all requests for a specified time interval. You should avoid hitting this too often. Intents and Caching \u00b6 Cannot get reference as it has already been Garbage Collected \u00b6 Due to how we structure cache we sometimes have to invalidate our entire cache (that's just how Discord works). When you store references to JDA entities for a long period of time such as a field you will suffer with the error java.lang.IllegalStateException: Cannot get reference as it has already been Garbage Collected once the entity was removed from the JDA cache. We highly recommend to store only the parts you actually need of the specific entity such as id and use something like event.getJDA().getRoleById(id) . Entities that should not be stored for a long period of time include: Role Channel (any type of channel) Guild RichCustomEmoji User Message Instead store IDs of the entities, or for messages simply the parts you need such as content. Users/Members not in cache \u00b6 The default behavior in createDefault is to only cache members connected to voice channels. If you need members to be cached, for example to lookup users by roles, then you have to enable this explicitly. I explained this in this wiki page and this stackoverflow answer . There are many ways you can retrieve members dynamically: Loading Members Cannot get message content / Attempting to access message content without GatewayIntent \u00b6 When you receive this warning, that means you tried to access the content of a message without the privileged GatewayIntent.MESSAGE_CONTENT . Attempting to access message content without GatewayIntent.MESSAGE_CONTENT. Discord now requires to explicitly enable access to this using the MESSAGE_CONTENT intent. Useful resources to learn more: - https://support-dev.discord.com/hc/en-us/articles/4404772028055-Message-Content-Privileged-Intent-FAQ - https://jda.wiki/using-jda/gateway-intents-and-member-cache-policy/ - https://jda.wiki/using-jda/troubleshooting/#im-getting-closecode4014-disallowed-intents Or suppress this warning if this is intentional with Message.suppressContentIntentWarning() As of JDA version 5.0.0-alpha.14 , you are required to enable this intent explicitly with enableIntents(GatewayIntent.MESSAGE_CONTENT) on your JDABuilder or DefaultShardManagerBuilder . This affects anyone who accesses these methods on messages: getContentRaw , getContentDisplay , getContentStripped , and getMentions().getCustomEmojis() getActionRows , and getButtons getAttachments getEmbeds You are also required to enable this in your application dashboard . Note, however, that this is a privileged intent and will require a valid use-case for your bot to be verified in over 75 servers. I'm getting CloseCode(4014 / Disallowed intents...) \u00b6 This means you tried to use GatewayIntent.GUILD_MEMBERS , GatewayIntent.GUILD_PRESENCES , or GatewayIntent.MESSAGE_CONTENT without enabling it in your application dashboard. To use these privileged intents you first have to enable them. Open the application dashboard Select your bot application Open the Bot tab Under the Privileged Gateway Intents section, enable the intents that you are using in your bot. Toggle on SERVER MEMBERS INTENT , PRESENCE INTENT , or MESSAGE CONTENT INTENT depending on your needs. If you use these intents you are limited to 100 guilds on your bot. To allow the bot to join more guilds while using this intent you have to verify your bot . This will be available in your application dashboard when the bot joins at least 75 guilds. Interactions and Slash Commands \u00b6 This interaction failed / Unknown Interaction \u00b6 This means you didn't acknowledge or reply to an interaction in time. You only have 3 seconds to reply or acknowledge. You have to use event.deferReply().queue() , event.deferEdit().queue() , event.editMessage(...).queue() , or event.reply(...).queue() . (If you don't queue() it won't do it) Make sure your event listener code is executed. Interaction Followup Messages Timed out \u00b6 This means you sent followup messages through InteractionHook.sendMessage(...) or similar but never acknowledged the interaction.","title":"Troubleshooting"},{"location":"using-jda/troubleshooting/#troubleshooting","text":"This is a collection of common issues and recommended solutions. Didn't find an answer? Try asking in our Discord server","title":"Troubleshooting"},{"location":"using-jda/troubleshooting/#shutdown-but-the-process-doesnt-exit","text":"When you call JDA.shutdown() or JDA.shutdownNow() the JDA instance will stop all of its threads. However, if HTTP/2 was used by the OkHttpClient instance it will keep the JVM running due to a timeout thread for http connections. This can be terminated by shutting it down manually: OkHttpClient client = jda . getHttpClient (); client . connectionPool (). evictAll (); client . dispatcher (). executorService (). shutdown ();","title":"Shutdown but the process doesn't exit"},{"location":"using-jda/troubleshooting/#noclassdeffounderror-or-classnotfoundexception-on-startup","text":"An error like java.lang.NoClassDefFoundError: net/dv8tion/jda/api/JDABuilder or similar means you are not including your dependencies or transitive dependencies in the archive. Gradle (build.gradle) Maven (pom.xml) Jar With Gradle this can be fixed by using the shadow plugin and building your jar with shadowJar instead. The jar will then be present in the build/libs directory with a name like example-1.0-all.jar With Maven you need the shade plugin in your pom to add dependencies to your package task. You can see the shade plugin being applied in this example pom.xml You need to use the -withDependencies.jar rather than the normal one.","title":"NoClassDefFoundError or ClassNotFoundException on startup"},{"location":"using-jda/troubleshooting/#discord-issues-and-api-limitations","text":"","title":"Discord Issues and API Limitations"},{"location":"using-jda/troubleshooting/#the-provided-token-is-invalid","text":"javax.security.auth.login.LoginException: The provided token is invalid! This exception indicates that the token you have used in your JDABuilder is not a valid bot token. Usually, this means you tried using the secret instead of the bot token. To get your token, follow these steps: Open the Application Dashboard Select your application On the left side, click the Bot tab If you don't have a bot yet, you must create one Once you have a bot, there is a token section. Click COPY . The token is now in your clipboard and you can paste it into your code If you follow these steps and you still get the same exception, it could be due to one of these problems: You included excess whitespace in your string. The token string should not include any newlines or spaces. You were banned from the API or your server is hosted on a public hosting platform like Glitch or Heroku. The token is not for a bot account, we do not support client accounts. A valid token looks like this: NDkyNzQ3NzY5MDM2MDEzNTc4.Xw2cUA.LLslVBE1tfFK20sGsNm-FVFYdsA Caution NEVER SHARE YOUR TOKEN WITH ANYONE. DO NOT COMMIT IT AND PUSH IT TO GITHUB. DO NOT SHOW IT TO ANYONE UNDER ANY CIRCUMSTANCES.","title":"The provided token is invalid!"},{"location":"using-jda/troubleshooting/#cant-get-emoji-from-message","text":"Methods such as Mentions.getCustomEmojis() and Mentions.getCustomEmojisBag() only include custom emoji which have to be uploaded to a guild by a moderator. Unicode emoji such as \ud83d\udc4d are not included and require using a 3rd party library to be located in a string. You can use emoji-java to extract unicode emoji from a message. An example use-case including a code sample can be found in this answer to a related question on StackOverflow","title":"Can't get emoji from message"},{"location":"using-jda/troubleshooting/#event-handling-and-restactions","text":"","title":"Event Handling and RestActions"},{"location":"using-jda/troubleshooting/#restaction-queue-returned-failure","text":"When JDA encounters an issue while executing a RestAction it will emit an error through the failure callback . You can handle this by adding a second callback to queue() , for example: message.delete().queue(v -> System.out.println(\"success\"), ContextException.herePrintingTrace\u200b()); . Example public void deleteMessage ( Message message ) { message . delete (). queue ( null , ( exception ) -> { message . getChannel (). sendMessage ( \"There was an error \" + exception ). queue (); }); } You can use ErrorHandler to handle or ignore specific ErrorResponse failures.","title":"RestAction queue returned failure"},{"location":"using-jda/troubleshooting/#nothing-happens-when-using-x","text":"In JDA we make use of async rate-limit handling through the use of the common RestAction class. When you have code such as channel.sendMessage(\"hello\"); or message.delete(); nothing actually happens. This is because both sendMessage(...) as well as delete() return a RestAction instance. You are not done here since that class is only an intermediate step to executing your request. Here you can decide to use async queue() (recommended) or submit() or the blocking complete() (not recommended). You might notice that queue() returns void . This is because it's async and uses callbacks instead. Read More If you do have a queue() then maybe your code doesn't even run? Try putting a System.out.println(\"debug\") right before and after your code and see if it prints. If not, then read this My event listener code is not executed .","title":"Nothing happens when using X"},{"location":"using-jda/troubleshooting/#my-event-listener-code-is-not-executed","text":"There are many reasons why your event listener might not be executed but here are the most common issues: You are using a deprecated or removed part of JDA, such as new JDABuilder(...) . Use the replacement that is documented, for example createDefault(token) . You are using the wrong login token. If the token is for another bot which doesn't have access to the desired guilds then the event listener code cannot run. Your bot is not actually in the guild. Make sure your bot is online and has access to the resource you are trying to interact with. You never registered your listener. Use jda.addEventListener(new MyListener()) on either the JDABuilder or JDA instance You did not override the correct method. Use @Override and see if it fails. Your method has to use the correct name and parameter list defined in ListenerAdapter . Read More . You don't actually extend EventListener or ListenerAdapter . Your class should either use extends ListenerAdapter or implements EventListener . You are missing a required GatewayIntent for this event. Make sure that you enableIntents(...) on the JDABuilder to allow the events to be received. The event has other requirements that might not be satisfied such as the cache not being enabled. Please check the requirements on the event documentation. If none of the above apply to you then you might have an issue in your listener's code, at that point you should use a debugger.","title":"My event listener code is not executed"},{"location":"using-jda/troubleshooting/#missed-2-heartbeats-trying-to-reconnect","text":"This warning implies your event thread is too busy and will block critical events from being received. You should try to limit blocking calls and make sure your event handlers don't take up too much time. Do profiling to figure out what takes so long or create a thread dump when you get this warning to see where the issue is. By default, all events are handled on the same thread they get received and handled on. If you block this thread for too long then JDA cannot keep up with important lifecycle events sent by Discord. Either you start writing non-blocking code (replace complete() with queue() etc.) or you use a thread pool for your event handling.","title":"Missed 2 heartbeats! Trying to reconnect..."},{"location":"using-jda/troubleshooting/#listener-must-implement-eventlistener","text":"Exception in thread \"main\" java.lang.IllegalArgumentException: Listener must implement EventListener at net.dv8tion.jda.api.hooks.InterfacedEventManager.register(InterfacedEventManager.java:62) at net.dv8tion.jda.internal.hooks.EventManagerProxy.register(EventManagerProxy.java:52) at net.dv8tion.jda.internal.JDAImpl.addEventListener(JDAImpl.java:810) at net.dv8tion.jda.api.JDABuilder.lambda$build$0(JDABuilder.java:1841) at java.base/java.lang.Iterable.forEach(Iterable.java:75) at net.dv8tion.jda.api.JDABuilder.build(JDABuilder.java:1841) When you get an exception like this, that means one of the event listeners you registered does not implement the EventListener interface provided by JDA. This is not a valid event listener class: public class MyListener { ... } You can either use ListenerAdapter or EventListener : import net.dv8tion.jda.api.hooks.ListenerAdapter ; public class MyListener extends ListenerAdapter { ... } When using EventListner make sure you actually imported the correct interface from JDA and not java.util.EventListner : import net.dv8tion.jda.api.events.GenericEvent ; import net.dv8tion.jda.api.hooks.EventListener ; public class MyListener extends EventListener { @Override public void onEvent ( GenericEvent event ) { ... } } Read More","title":"Listener must implement EventListener"},{"location":"using-jda/troubleshooting/#i-cant-get-the-previous-message-content-from-deleteupdate","text":"When Discord emits a message_delete or message_update they only provide the new content of the message. Since JDA does not keep a cache of messages it is unable to provide the previous content. Instead you will have to track content of messages yourself.","title":"I can't get the previous message content from delete/update"},{"location":"using-jda/troubleshooting/#preventing-use-of-complete-in-callback-threads","text":"The following code will illustrate an issue where callbacks might cause a deadlock class Main { public static main ( String [] args ) { JDA api = JDABuilder . createDefault ( BOT_TOKEN ) . setCallbackPool ( Executors . newSingleThreadScheduledExecutor ()) // (1) . build (). awaitReady (); TextChannel channel = api . getTextChannelById ( CHANNEL_ID ); channel . sendMessage ( \"hello there\" ). queue (( message ) -> { // (2) System . out . println ( \"Hello\" ); message . editMessage ( \"general kenobi\" ). complete (); // (3) deadlock System . out . println ( \"World!!!!\" ); // never printed }); } } You can test this yourself on 3.8.0 and see it fail. Since we decided to use a single-thread pool (1) we only have one thread to execute callbacks. This thread is used by the first callback (2) and cannot be used for the second callback (3). Due to this reason we simply don't allow using complete() in any callback threads at all. If you use callbacks you should use queue() .","title":"Preventing use of complete() in callback threads"},{"location":"using-jda/troubleshooting/#ratelimits","text":"","title":"RateLimits"},{"location":"using-jda/troubleshooting/#hit-the-websocket-ratelimit","text":"When you update your game or online status you emit a socket message to Discord. If you do that often enough you hit a limit and JDA has to backoff for 60 seconds. Things that contribute to the WebSocket RateLimit include: AudioManager.openAudioConnection(...) AudioManager.closeAudioConnection() AudioManager.setSelfMuted(...) AudioManager.setSelfDeafened(...) Any setter method on Presence . It is also possible that you get spammed by this warning if you use ChunkingFilter.ALL (this is done when using create(token, intents) ). If your bot is in more than 120 guilds then this warning is unavoidable when using member chunking. It is recommended to use setChunkingFilter(ChunkingFilter.NONE) to reduce the startup time and get rid of this warning. If chunking on startup is absolutely necessary, you have to accept this warning. There are many ways to retrieve members: Loading Members I explained this in a bit more detail in issue #1290 To make chunking a little more efficient, you can additionally enable the GatewayIntent.GUILD_PRESENCES . This will load all online members for each guild directly, instead of relying on additional member chunk requests, which can be a significant boost to reduce startup time and potentially reduce these warnings.","title":"Hit the WebSocket RateLimit"},{"location":"using-jda/troubleshooting/#encountered-429-or-encountered-global-rate-limit","text":"When the internal jda rate-limiter fails to predict a rate limit bucket the HTTP response is 429: TOO MANY REQUESTS . This means the request has to be retried. If you see this a lot (many times per minute), then JDA might have an issue with the rate limit handling of that route. If you use setRelativeRateLimit(false) it could also mean that your clock is not properly synchronizing with NTP. Encountering the global rate-limit is something JDA cannot predict or prevent. This rate-limit implies you sent too many requests in total across all routes. Discord limits how much HTTP traffic a client is allowed to do and will tell us to limit all requests for a specified time interval. You should avoid hitting this too often.","title":"Encountered 429 or Encountered global rate limit"},{"location":"using-jda/troubleshooting/#intents-and-caching","text":"","title":"Intents and Caching"},{"location":"using-jda/troubleshooting/#cannot-get-reference-as-it-has-already-been-garbage-collected","text":"Due to how we structure cache we sometimes have to invalidate our entire cache (that's just how Discord works). When you store references to JDA entities for a long period of time such as a field you will suffer with the error java.lang.IllegalStateException: Cannot get reference as it has already been Garbage Collected once the entity was removed from the JDA cache. We highly recommend to store only the parts you actually need of the specific entity such as id and use something like event.getJDA().getRoleById(id) . Entities that should not be stored for a long period of time include: Role Channel (any type of channel) Guild RichCustomEmoji User Message Instead store IDs of the entities, or for messages simply the parts you need such as content.","title":"Cannot get reference as it has already been Garbage Collected"},{"location":"using-jda/troubleshooting/#usersmembers-not-in-cache","text":"The default behavior in createDefault is to only cache members connected to voice channels. If you need members to be cached, for example to lookup users by roles, then you have to enable this explicitly. I explained this in this wiki page and this stackoverflow answer . There are many ways you can retrieve members dynamically: Loading Members","title":"Users/Members not in cache"},{"location":"using-jda/troubleshooting/#cannot-get-message-content-attempting-to-access-message-content-without-gatewayintent","text":"When you receive this warning, that means you tried to access the content of a message without the privileged GatewayIntent.MESSAGE_CONTENT . Attempting to access message content without GatewayIntent.MESSAGE_CONTENT. Discord now requires to explicitly enable access to this using the MESSAGE_CONTENT intent. Useful resources to learn more: - https://support-dev.discord.com/hc/en-us/articles/4404772028055-Message-Content-Privileged-Intent-FAQ - https://jda.wiki/using-jda/gateway-intents-and-member-cache-policy/ - https://jda.wiki/using-jda/troubleshooting/#im-getting-closecode4014-disallowed-intents Or suppress this warning if this is intentional with Message.suppressContentIntentWarning() As of JDA version 5.0.0-alpha.14 , you are required to enable this intent explicitly with enableIntents(GatewayIntent.MESSAGE_CONTENT) on your JDABuilder or DefaultShardManagerBuilder . This affects anyone who accesses these methods on messages: getContentRaw , getContentDisplay , getContentStripped , and getMentions().getCustomEmojis() getActionRows , and getButtons getAttachments getEmbeds You are also required to enable this in your application dashboard . Note, however, that this is a privileged intent and will require a valid use-case for your bot to be verified in over 75 servers.","title":"Cannot get message content / Attempting to access message content without GatewayIntent"},{"location":"using-jda/troubleshooting/#im-getting-closecode4014-disallowed-intents","text":"This means you tried to use GatewayIntent.GUILD_MEMBERS , GatewayIntent.GUILD_PRESENCES , or GatewayIntent.MESSAGE_CONTENT without enabling it in your application dashboard. To use these privileged intents you first have to enable them. Open the application dashboard Select your bot application Open the Bot tab Under the Privileged Gateway Intents section, enable the intents that you are using in your bot. Toggle on SERVER MEMBERS INTENT , PRESENCE INTENT , or MESSAGE CONTENT INTENT depending on your needs. If you use these intents you are limited to 100 guilds on your bot. To allow the bot to join more guilds while using this intent you have to verify your bot . This will be available in your application dashboard when the bot joins at least 75 guilds.","title":"I'm getting CloseCode(4014 / Disallowed intents...)"},{"location":"using-jda/troubleshooting/#interactions-and-slash-commands","text":"","title":"Interactions and Slash Commands"},{"location":"using-jda/troubleshooting/#this-interaction-failed-unknown-interaction","text":"This means you didn't acknowledge or reply to an interaction in time. You only have 3 seconds to reply or acknowledge. You have to use event.deferReply().queue() , event.deferEdit().queue() , event.editMessage(...).queue() , or event.reply(...).queue() . (If you don't queue() it won't do it) Make sure your event listener code is executed.","title":"This interaction failed / Unknown Interaction"},{"location":"using-jda/troubleshooting/#interaction-followup-messages-timed-out","text":"This means you sent followup messages through InteractionHook.sendMessage(...) or similar but never acknowledged the interaction.","title":"Interaction Followup Messages Timed out"},{"location":"using-jda/using-new-features/","text":"Using New Features \u00b6 When contributors are making new features, like introducing modals, you might be interested in trying out or testing these features before they get released. Using JitPack \u00b6 Using JitPack, you can get a build of any fork of JDA, on any branch, on any commit. It is still highly recommended that you use a build tool such as Gradle or Maven . Getting the Necessary Info \u00b6 Let's take the PR for the Discord modals as an example. You will need the author's name, which here is xirado . Getting the Latest Version \u00b6 Next, head to the Commits tab. You can now scroll down to the bottom, as to find the latest commit hash . It should look like this: Here you can see the 7 first characters of the latest commit are 36eea2a . Putting It Together \u00b6 So far we have: PR author name: xirado Version (7 character commit hash): 36eea2a You can now add the dependency to your project using your favorite build tool, but don't forget to remove your current JDA dependency first. Template: Gradle Maven repositories { mavenCentral () maven { url 'https://jitpack.io' } } dependencies { implementation ( \"com.github.AuthorName:JDA:CommitHash\" ) } Put this in your <repositories> tag <repository> <id> jitpack </id> <url> https://jitpack.io </url> </repository> and then this, in your <dependencies> tag <dependency> <groupId> com.github.AuthorName </groupId> <artifactId> JDA </artifactId> <version> CommitHash </version> </dependency> With our example: Gradle Maven repositories { mavenCentral () maven { url 'https://jitpack.io' } } dependencies { implementation ( \"com.github.xirado:JDA:36eea2a\" ) } Put this in your <repositories> tag <repository> <id> jitpack </id> <url> https://jitpack.io </url> </repository> and then this, in your <dependencies> tag <dependency> <groupId> com.github.xirado </groupId> <artifactId> JDA </artifactId> <version> 36eea2a </version> </dependency>","title":"Using New Features"},{"location":"using-jda/using-new-features/#using-new-features","text":"When contributors are making new features, like introducing modals, you might be interested in trying out or testing these features before they get released.","title":"Using New Features"},{"location":"using-jda/using-new-features/#using-jitpack","text":"Using JitPack, you can get a build of any fork of JDA, on any branch, on any commit. It is still highly recommended that you use a build tool such as Gradle or Maven .","title":"Using JitPack"},{"location":"using-jda/using-new-features/#getting-the-necessary-info","text":"Let's take the PR for the Discord modals as an example. You will need the author's name, which here is xirado .","title":"Getting the Necessary Info"},{"location":"using-jda/using-new-features/#getting-the-latest-version","text":"Next, head to the Commits tab. You can now scroll down to the bottom, as to find the latest commit hash . It should look like this: Here you can see the 7 first characters of the latest commit are 36eea2a .","title":"Getting the Latest Version"},{"location":"using-jda/using-new-features/#putting-it-together","text":"So far we have: PR author name: xirado Version (7 character commit hash): 36eea2a You can now add the dependency to your project using your favorite build tool, but don't forget to remove your current JDA dependency first. Template: Gradle Maven repositories { mavenCentral () maven { url 'https://jitpack.io' } } dependencies { implementation ( \"com.github.AuthorName:JDA:CommitHash\" ) } Put this in your <repositories> tag <repository> <id> jitpack </id> <url> https://jitpack.io </url> </repository> and then this, in your <dependencies> tag <dependency> <groupId> com.github.AuthorName </groupId> <artifactId> JDA </artifactId> <version> CommitHash </version> </dependency> With our example: Gradle Maven repositories { mavenCentral () maven { url 'https://jitpack.io' } } dependencies { implementation ( \"com.github.xirado:JDA:36eea2a\" ) } Put this in your <repositories> tag <repository> <id> jitpack </id> <url> https://jitpack.io </url> </repository> and then this, in your <dependencies> tag <dependency> <groupId> com.github.xirado </groupId> <artifactId> JDA </artifactId> <version> 36eea2a </version> </dependency>","title":"Putting It Together"},{"location":"using-jda/using-restaction/","text":"What is a RestAction? \u00b6 If you understand RestAction you understand JDA. In JDA 3.0 we introduced the new RestAction class which basically is a terminal between the JDA user and the Discord REST API. The RestAction is a step between specifying what the user wants to do and executing it, it allows the user to specify how JDA should deal with their Request . However this only works if you actually tell the RestAction to do something . That is why we recommend checking out whether or not something in JDA returns a RestAction . If that is the case you have to execute it using one of the RestAction execution operations: queue() , queue(Consumer) , queue(Consumer, Consumer) These operations are asynchronous and will not execute within the same Thread. This means that you cannot use procedural logic when you use queue() , unless you use the callback Consumers. Only similar requests are internally executed in sequence such as sending messages in the same channel or adding reactions to the same message. submit() Provides request future to cancel tasks later and avoid callback hell. complete() This operation will block the current Thread until the request has been finished and will return the response type. Note We recommend using queue() or submit() when possible as blocking the current Thread can cause downtime and will use more resources. Since 4.1.1 you can use a few RestAction operators to avoid callback hell with queue: map Convert the result of the RestAction to a different value flatMap Chain another RestAction on the result delay Delay the element of the previous step JavaDocs : https://ci.dv8tion.net/job/JDA/javadoc/net/dv8tion/jda/api/requests/RestAction.html AuditLog Reasons \u00b6 Some operations return a special RestAction implementation called AuditableRestAction . This extension allows to set a reason field for that action. Example public class ModerationUtil { public static void deleteMessage ( Message message , String reason ) { message . delete (). reason ( reason ). queue (); } public static void ban ( Guild guild , User user , String reason ) { guild . ban ( user , 7 , reason ). queue (); } } Using queue() \u00b6 The most common way to execute a RestAction is by simply calling .queue() after the operation: public void sendMessage ( MessageChannel channel , String message ) { channel . sendMessage ( message ). queue (); } This will always simply execute the RestAction<Message> which was returned by MessageChannel.sendMessage(String) . Note that this might happen after calling sendMessage(MessageChannel, String) because queue() is asynchronous ! You: Why can't I access the Message that was sent with queue() ? Minn: Use the success callback! Is one of the common conversations we had when people started using JDA 3.0. You: What does that mean? A success callback is what we call the primary Consumer that can be passed to a queue() statement: public void sendAndLog ( MessageChannel channel , String message ) { channel . sendMessage ( message ). queue ( new Consumer < Message > () { @Override public void accept ( Message t ) { System . out . printf ( \"Sent Message %s\\n\" , t ); } }); } Here we used an inline implementation of Consumer<Message> that handles the response of a REST Request. The method Consumer.accept(Message) is automatically called once the response has been received by the JDA Requester. Minn: But that looks really ugly... You: Yeah but it works!! Since JDA requires you to use Java 1.8 we can use one of the new features: Lambda Expressions public void sendAndLog ( MessageChannel channel , String message ) { // Here we use a lambda expressions which names the callback parameter -response- and uses that as a reference // in the callback body -System.out.printf(\"Sent Message %s\\n\", response)- Consumer < Message > callback = ( response ) -> System . out . printf ( \"Sent Message %s\\n\" , response ); channel . sendMessage ( message ). queue ( callback ); // ^ calls that } You: Wow that looks so much better! Minn: Yes, please learn more about lambda expressions: lambda quickstart Example: Sending a Private Message public void sendPrivateMessage ( User user , String content ) { // openPrivateChannel provides a RestAction<PrivateChannel> // which means it supplies you with the resulting channel user . openPrivateChannel (). queue (( channel ) -> { // value is a parameter for the `accept(T channel)` method of our callback. // here we implement the body of that method, which will be called later by JDA automatically. channel . sendMessage ( content ). queue (); // here we access the enclosing scope variable -content- // which was provided to sendPrivateMessage(User, String) as a parameter }); } Since this only calls a single method in the callback you can use the short form: public void sendPrivateMessage ( User user , String content ) { // notice that we are not placing a semicolon (;) in the callback this time! user . openPrivateChannel (). queue ( ( channel ) -> channel . sendMessage ( content ). queue () ); } Using submit() \u00b6 Sometimes execution needs to be cancelled if it isn't required anymore. This can be challenging to do if you use queue() or complete() . In submit() JDA will provide a CompletableFuture (aka promise) which allows the cancellation of a request. If you don't need to use the CompletableFuture you may use queue() instead! Example public void setTestingChannel ( TextChannel channel ) { channel . getManager (). setName ( \"testing-channel\" ). queue ( ( v ) -> channel . sendMessage ( \"Update Channel\" ). queue ( ( m ) -> m . delete (). queueAfter ( 30 , TimeUnit . SECONDS , ( t ) -> logChannel . sendMessage ( \"Deleted Response in %s\" , channel ). queue () ) ) ); } // turns into public void setTestingChannel ( TextChannel channel ) { channel . getManager (). setName ( \"testing-channel\" ). submit () // CompletableFuture<Void> . thenCompose (( v ) -> channel . sendMessage ( \"Update Channel\" ). submit ()) // CompletableFuture<Message> . thenCompose (( m ) -> m . delete (). submitAfter ( 30 , TimeUnit . SECONDS )) // CompletableFuture<Void> . thenCompose (( v ) -> logChannel . sendMessage ( \"Deleted Response in %s\" , channel ). submit ()) . whenComplete (( s , error ) -> { // this will be called for every termination (success/failure) // if the result is successful the error will be null // otherwise you should handle the error here to prevent it from being eaten and never printed if ( error != null ) error . printStackTrace (); }); } Note You can do the same with RestAction#flatMap in 4.1.1 public class RateLimitListener extends ListenerAdapter { private final long guildId ; private final long userId ; private final Queue < RequestFuture < Void >> tasks = new LinkedList <> (); public RateLimitListener ( Guild guild , User user ) { guildId = guild . getIdLong (); userId = user . getIdLong (); // only store IDs as JDA objects can be disposed by cache invalidation //when disposed the entity is not usable anymore, since we only need the id this is good enough } @Override public void onGuildMessageReceived ( GuildMessageReceivedEvent event ) { if ( event . getAuthor (). getIdLong () != userId ) return ; // ignore other users if ( event . getGuild (). getIdLong () != guildId ) return ; // ignore other guilds RequestFuture < Void > task = event . getMessage (). delete (). submit (); tasks . add ( task ); // add task to cancel queue in case user gets banned task . thenRun (() -> tasks . remove ( task )); // remove once completed } @Override public void onGuildBan ( GuildBanEvent event ) { if ( event . getUser (). getIdLong () != userId ) return ; // ignore other users if ( event . getGuild (). getIdLong () != guildId ) return ; // ignore other guilds // stop deleting messages for banned user RequestFuture < Void > current ; while (( current = tasks . poll ()) != null ) current . cancel ( true ); tasks . clear (); // remove this as listener, our task has completed! event . getJDA (). removeEventListener ( this ); } } Using complete() \u00b6 The complete() operation is simply for your convenience. It will block the Thread that you call it on which means it will not be able to continue with other tasks in the meantime. If you don't use the return value or don't need the request to be completed before continuing with other operations it is recommended to use queue() instead! Example public void setTestingChannel ( TextChannel channel ) { channel . getManager (). setName ( \"testing-channel\" ). queue ( ( v ) -> channel . sendMessage ( \"Update Channel\" ). queue ( ( m ) -> m . delete (). queueAfter ( 30 , TimeUnit . SECONDS , ( t ) -> logChannel . sendMessage ( \"Deleted Response in %s\" , channel ). queue () ) ) ); } public void setTestingChannelBlocking ( TextChannel channel ) { channel . getManager (). setName ( \"testing-channel\" ). complete (); Message m = channel . sendMessage ( \"Update Channel\" ). complete (); m . delete (). completeAfter ( 30 , TimeUnit . SECONDS ); logChannel . sendMessage ( \"Deleted Response in %s\" , channel ). queue (); // note how we used queue in the end because we don't need it sequenced anymore. } This is called a callback hell public Message sendAndLog ( MessageChannel channel , String message ) { Message response = channel . sendMessage ( message ). complete (); System . out . printf ( \"Sent Message %s\\n\" , response ); return response ; } public PermissionOverride getOverride ( Channel channel , Member member ) { final PermissionOverride override = channel . getPermissionOverride ( member ); if ( override == null ) return channel . createPermissionOverride ( member ). complete (); return override ; } You can do this asynchronously by using a CompletableFuture : public CompletableFuture < PermissionOverride > getOverride ( Channel channel , Member member ) { final PermissionOverride override = channel . getPermissionOverride ( member ); if ( override == null ) return channel . createPermissionOverride ( member ). submit (); return CompletableFuture . completedFuture ( override ); } getOverride ( channel , member ). thenAccept ( override -> ...); Using completeAfter , submitAfter and queueAfter \u00b6 These three methods are also known under the term of Planned Execution as they use a ScheduledExecutorService to schedule calls to either complete or queue . There are three possible ways to plan a RestAction execution completeAfter(long, TimeUnit) Blocks and executes on the current Thread, similar to complete() ! Similar to using Thread.join() this will block until the action has completed. submitAfter(long, TimeUnit) , submitAfter(long, TimeUnit, ScheduledExecutorService) Creates a DelayedCompletableFuture<T> which will hold the response type as its generic value. This means using get() on the returned Future will cause the current thread to block and await the execution of the RestAction and receive the response type. queueAfter(long, TimeUnit) , queueAfter(long, TimeUnit, Consumer<T>) , queueAfter(long, TimeUnit, Consumer<T>, Consumer<Throwable>) Schedules the RestAction execution to be started after the specified delay, this will not block the thread and handle the execution in the background. You can optionally provide a ScheduledExecutorService to any of the queueAfter operations as the last argument. When no ScheduledExecutorService is provided, these operations will use the default internal JDA ScheduledExecutorService that is also used to execute queue callback consumers. Example completeAfter public Message waitForEdit ( Message message ) { return message . editMessage ( \"5 Minutes are over\" ). completeAfter ( 5 , TimeUnit . MINUTES ); } Example queueAfter public void remind ( User user , String reminder , long delay , TimeUnit unit ) { user . openPrivateChannel (). queue ( ( channel ) -> channel . sendMessage ( reminder ). queueAfter ( delay , unit ) ); } public void remindAlternate ( User user , String reminder , long delay , TimeUnit unit ) { user . openPrivateChannel (). queueAfter ( delay , unit , ( channel ) -> channel . sendMessage ( reminder ). queue () ); } Example submitAfter private Map < String , DelayedCompletableFuture < Message >> tasks = new HashMap <> (); public ScheduledFuture < Message > sendWithTask ( MessageChannel channel , String message ) { DelayedCompletable < Message > task = channel . sendMessage ( message ). submitAfter ( 5 , TimeUnit . SECONDS ); return task ; } public void doSomething ( MessageChannel channel , String message ) throws Exception { tasks . add ( channel . getId (), sendWithTask ( channel , message )); for ( DelayedCompletable < Message > task : tasks . values ()) { // non-blocking alternative is `thenAccept` System . out . printf ( \"Task completed: %s\\n\" , task . get ()); } }","title":"Using RestAction"},{"location":"using-jda/using-restaction/#what-is-a-restaction","text":"If you understand RestAction you understand JDA. In JDA 3.0 we introduced the new RestAction class which basically is a terminal between the JDA user and the Discord REST API. The RestAction is a step between specifying what the user wants to do and executing it, it allows the user to specify how JDA should deal with their Request . However this only works if you actually tell the RestAction to do something . That is why we recommend checking out whether or not something in JDA returns a RestAction . If that is the case you have to execute it using one of the RestAction execution operations: queue() , queue(Consumer) , queue(Consumer, Consumer) These operations are asynchronous and will not execute within the same Thread. This means that you cannot use procedural logic when you use queue() , unless you use the callback Consumers. Only similar requests are internally executed in sequence such as sending messages in the same channel or adding reactions to the same message. submit() Provides request future to cancel tasks later and avoid callback hell. complete() This operation will block the current Thread until the request has been finished and will return the response type. Note We recommend using queue() or submit() when possible as blocking the current Thread can cause downtime and will use more resources. Since 4.1.1 you can use a few RestAction operators to avoid callback hell with queue: map Convert the result of the RestAction to a different value flatMap Chain another RestAction on the result delay Delay the element of the previous step JavaDocs : https://ci.dv8tion.net/job/JDA/javadoc/net/dv8tion/jda/api/requests/RestAction.html","title":"What is a RestAction?"},{"location":"using-jda/using-restaction/#auditlog-reasons","text":"Some operations return a special RestAction implementation called AuditableRestAction . This extension allows to set a reason field for that action. Example public class ModerationUtil { public static void deleteMessage ( Message message , String reason ) { message . delete (). reason ( reason ). queue (); } public static void ban ( Guild guild , User user , String reason ) { guild . ban ( user , 7 , reason ). queue (); } }","title":"AuditLog Reasons"},{"location":"using-jda/using-restaction/#using-queue","text":"The most common way to execute a RestAction is by simply calling .queue() after the operation: public void sendMessage ( MessageChannel channel , String message ) { channel . sendMessage ( message ). queue (); } This will always simply execute the RestAction<Message> which was returned by MessageChannel.sendMessage(String) . Note that this might happen after calling sendMessage(MessageChannel, String) because queue() is asynchronous ! You: Why can't I access the Message that was sent with queue() ? Minn: Use the success callback! Is one of the common conversations we had when people started using JDA 3.0. You: What does that mean? A success callback is what we call the primary Consumer that can be passed to a queue() statement: public void sendAndLog ( MessageChannel channel , String message ) { channel . sendMessage ( message ). queue ( new Consumer < Message > () { @Override public void accept ( Message t ) { System . out . printf ( \"Sent Message %s\\n\" , t ); } }); } Here we used an inline implementation of Consumer<Message> that handles the response of a REST Request. The method Consumer.accept(Message) is automatically called once the response has been received by the JDA Requester. Minn: But that looks really ugly... You: Yeah but it works!! Since JDA requires you to use Java 1.8 we can use one of the new features: Lambda Expressions public void sendAndLog ( MessageChannel channel , String message ) { // Here we use a lambda expressions which names the callback parameter -response- and uses that as a reference // in the callback body -System.out.printf(\"Sent Message %s\\n\", response)- Consumer < Message > callback = ( response ) -> System . out . printf ( \"Sent Message %s\\n\" , response ); channel . sendMessage ( message ). queue ( callback ); // ^ calls that } You: Wow that looks so much better! Minn: Yes, please learn more about lambda expressions: lambda quickstart Example: Sending a Private Message public void sendPrivateMessage ( User user , String content ) { // openPrivateChannel provides a RestAction<PrivateChannel> // which means it supplies you with the resulting channel user . openPrivateChannel (). queue (( channel ) -> { // value is a parameter for the `accept(T channel)` method of our callback. // here we implement the body of that method, which will be called later by JDA automatically. channel . sendMessage ( content ). queue (); // here we access the enclosing scope variable -content- // which was provided to sendPrivateMessage(User, String) as a parameter }); } Since this only calls a single method in the callback you can use the short form: public void sendPrivateMessage ( User user , String content ) { // notice that we are not placing a semicolon (;) in the callback this time! user . openPrivateChannel (). queue ( ( channel ) -> channel . sendMessage ( content ). queue () ); }","title":"Using queue()"},{"location":"using-jda/using-restaction/#using-submit","text":"Sometimes execution needs to be cancelled if it isn't required anymore. This can be challenging to do if you use queue() or complete() . In submit() JDA will provide a CompletableFuture (aka promise) which allows the cancellation of a request. If you don't need to use the CompletableFuture you may use queue() instead! Example public void setTestingChannel ( TextChannel channel ) { channel . getManager (). setName ( \"testing-channel\" ). queue ( ( v ) -> channel . sendMessage ( \"Update Channel\" ). queue ( ( m ) -> m . delete (). queueAfter ( 30 , TimeUnit . SECONDS , ( t ) -> logChannel . sendMessage ( \"Deleted Response in %s\" , channel ). queue () ) ) ); } // turns into public void setTestingChannel ( TextChannel channel ) { channel . getManager (). setName ( \"testing-channel\" ). submit () // CompletableFuture<Void> . thenCompose (( v ) -> channel . sendMessage ( \"Update Channel\" ). submit ()) // CompletableFuture<Message> . thenCompose (( m ) -> m . delete (). submitAfter ( 30 , TimeUnit . SECONDS )) // CompletableFuture<Void> . thenCompose (( v ) -> logChannel . sendMessage ( \"Deleted Response in %s\" , channel ). submit ()) . whenComplete (( s , error ) -> { // this will be called for every termination (success/failure) // if the result is successful the error will be null // otherwise you should handle the error here to prevent it from being eaten and never printed if ( error != null ) error . printStackTrace (); }); } Note You can do the same with RestAction#flatMap in 4.1.1 public class RateLimitListener extends ListenerAdapter { private final long guildId ; private final long userId ; private final Queue < RequestFuture < Void >> tasks = new LinkedList <> (); public RateLimitListener ( Guild guild , User user ) { guildId = guild . getIdLong (); userId = user . getIdLong (); // only store IDs as JDA objects can be disposed by cache invalidation //when disposed the entity is not usable anymore, since we only need the id this is good enough } @Override public void onGuildMessageReceived ( GuildMessageReceivedEvent event ) { if ( event . getAuthor (). getIdLong () != userId ) return ; // ignore other users if ( event . getGuild (). getIdLong () != guildId ) return ; // ignore other guilds RequestFuture < Void > task = event . getMessage (). delete (). submit (); tasks . add ( task ); // add task to cancel queue in case user gets banned task . thenRun (() -> tasks . remove ( task )); // remove once completed } @Override public void onGuildBan ( GuildBanEvent event ) { if ( event . getUser (). getIdLong () != userId ) return ; // ignore other users if ( event . getGuild (). getIdLong () != guildId ) return ; // ignore other guilds // stop deleting messages for banned user RequestFuture < Void > current ; while (( current = tasks . poll ()) != null ) current . cancel ( true ); tasks . clear (); // remove this as listener, our task has completed! event . getJDA (). removeEventListener ( this ); } }","title":"Using submit()"},{"location":"using-jda/using-restaction/#using-complete","text":"The complete() operation is simply for your convenience. It will block the Thread that you call it on which means it will not be able to continue with other tasks in the meantime. If you don't use the return value or don't need the request to be completed before continuing with other operations it is recommended to use queue() instead! Example public void setTestingChannel ( TextChannel channel ) { channel . getManager (). setName ( \"testing-channel\" ). queue ( ( v ) -> channel . sendMessage ( \"Update Channel\" ). queue ( ( m ) -> m . delete (). queueAfter ( 30 , TimeUnit . SECONDS , ( t ) -> logChannel . sendMessage ( \"Deleted Response in %s\" , channel ). queue () ) ) ); } public void setTestingChannelBlocking ( TextChannel channel ) { channel . getManager (). setName ( \"testing-channel\" ). complete (); Message m = channel . sendMessage ( \"Update Channel\" ). complete (); m . delete (). completeAfter ( 30 , TimeUnit . SECONDS ); logChannel . sendMessage ( \"Deleted Response in %s\" , channel ). queue (); // note how we used queue in the end because we don't need it sequenced anymore. } This is called a callback hell public Message sendAndLog ( MessageChannel channel , String message ) { Message response = channel . sendMessage ( message ). complete (); System . out . printf ( \"Sent Message %s\\n\" , response ); return response ; } public PermissionOverride getOverride ( Channel channel , Member member ) { final PermissionOverride override = channel . getPermissionOverride ( member ); if ( override == null ) return channel . createPermissionOverride ( member ). complete (); return override ; } You can do this asynchronously by using a CompletableFuture : public CompletableFuture < PermissionOverride > getOverride ( Channel channel , Member member ) { final PermissionOverride override = channel . getPermissionOverride ( member ); if ( override == null ) return channel . createPermissionOverride ( member ). submit (); return CompletableFuture . completedFuture ( override ); } getOverride ( channel , member ). thenAccept ( override -> ...);","title":"Using complete()"},{"location":"using-jda/using-restaction/#using-completeafter-submitafter-and-queueafter","text":"These three methods are also known under the term of Planned Execution as they use a ScheduledExecutorService to schedule calls to either complete or queue . There are three possible ways to plan a RestAction execution completeAfter(long, TimeUnit) Blocks and executes on the current Thread, similar to complete() ! Similar to using Thread.join() this will block until the action has completed. submitAfter(long, TimeUnit) , submitAfter(long, TimeUnit, ScheduledExecutorService) Creates a DelayedCompletableFuture<T> which will hold the response type as its generic value. This means using get() on the returned Future will cause the current thread to block and await the execution of the RestAction and receive the response type. queueAfter(long, TimeUnit) , queueAfter(long, TimeUnit, Consumer<T>) , queueAfter(long, TimeUnit, Consumer<T>, Consumer<Throwable>) Schedules the RestAction execution to be started after the specified delay, this will not block the thread and handle the execution in the background. You can optionally provide a ScheduledExecutorService to any of the queueAfter operations as the last argument. When no ScheduledExecutorService is provided, these operations will use the default internal JDA ScheduledExecutorService that is also used to execute queue callback consumers. Example completeAfter public Message waitForEdit ( Message message ) { return message . editMessage ( \"5 Minutes are over\" ). completeAfter ( 5 , TimeUnit . MINUTES ); } Example queueAfter public void remind ( User user , String reminder , long delay , TimeUnit unit ) { user . openPrivateChannel (). queue ( ( channel ) -> channel . sendMessage ( reminder ). queueAfter ( delay , unit ) ); } public void remindAlternate ( User user , String reminder , long delay , TimeUnit unit ) { user . openPrivateChannel (). queueAfter ( delay , unit , ( channel ) -> channel . sendMessage ( reminder ). queue () ); } Example submitAfter private Map < String , DelayedCompletableFuture < Message >> tasks = new HashMap <> (); public ScheduledFuture < Message > sendWithTask ( MessageChannel channel , String message ) { DelayedCompletable < Message > task = channel . sendMessage ( message ). submitAfter ( 5 , TimeUnit . SECONDS ); return task ; } public void doSomething ( MessageChannel channel , String message ) throws Exception { tasks . add ( channel . getId (), sendWithTask ( channel , message )); for ( DelayedCompletable < Message > task : tasks . values ()) { // non-blocking alternative is `thenAccept` System . out . printf ( \"Task completed: %s\\n\" , task . get ()); } }","title":"Using completeAfter, submitAfter and queueAfter"}]}